#!/bin/bash
#
########################################################################
#
# author:  Xavier Janssen                                08/03/2011
# purpose: Create and submit IIHE local job 
#          Full options !
#
########################################################################

###  COLORS


BLUE='\033[1;34m'
CYAN='\033[1;36m'
RED='\033[1;31m'
GREEN='\033[1;32m'
YEL='\033[1;33m'
YEL=$BLUE
DEF='\033[0;m'



### Usage:

Manual=`echo -e '
'"${BLUE}Possibilities:${DEF}"'

   btask '"${RED}-submit${DEF} <myconfile> [${CYAN}-tag${DEF} <mytag>] [${CYAN}-pnfs${DEF}] [${CYAN}-wtime${DEF} <HH:MM:SS>] "'
   btask '"${RED}-resubmit${DEF} [${CYAN}-t/-task${DEF} <mytaskname#tag>] [${CYAN}-wtime${DEF} <HH:MM:SS>] "'
   btask '"${RED}-s${DEF} [${CYAN}-t/-task${DEF} <mytaskname#tag>]"'
   btask '"${RED}-status${DEF} [${CYAN}-t/-task${DEF} <mytaskname#tag>]"'
   btask '"${RED}-hadd${DEF} [${CYAN}-t/-task${DEF} <mytaskname#tag>] [${CYAN}-def${DEF} <y/n>]"'
   btask '"${RED}-hadd_tweak${DEF} [${CYAN}-t/-task${DEF} <mytaskname#tag>] [${CYAN}-def${DEF} <y/n>]"'
   btask '"${RED}-get${DEF} [${CYAN}-t/-task${DEF} <mytaskname#tag>] [${CYAN}-tag${DEF} <mytag>] [${CYAN}-def${DEF} <y/n>] [${CYAN}-norename${DEF}] [${CYAN}-nojobid${DEF}] [${CYAN}-local_hadd${DEF}]"'  
   btask '"${RED}-kill${DEF} [${CYAN}-t/-task${DEF} <mytaskname#tag>]"'
   btask '"${RED}-help${DEF} "'

'"${BLUE}Description:${DEF}"'
For more details see '"${BLUE}https://twiki.cern.ch/twiki/bin/viewauth/CMS/UATools#Running_the_config_file${DEF}"'
'"\n    ${RED}submit ${DEF}"'    : to start submission of the task specified in the config file.
'"\n    ${CYAN}tag ${DEF}"'       : (optional) to have a user specified tag replacing the unique ID automatically created.
'"\n    ${CYAN}pnfs ${DEF}"'      : (optional) stores temporarily outputfiles on /pnfs rather than /localgrid, to circumvent the 50GB space-limit of localgrid.
'"\n    ${CYAN}wtime${DEF}"'      : (optional) At IIHE, specify the length of your jobs. Each job priority receives and extra factor: XF/<HH:MM:SS>, where XF is a constant.  
'"\n    ${RED}resubmit ${DEF}"'  : to resubmit subjobs with no outputs.
'"\n    ${RED}s ${DEF}"'         : to check the status of your tasks. Short output.
'"\n    ${RED}status ${DEF}"'    : same as -s option, but with long output. 
'"\n    ${RED}hadd ${DEF}"'      : In case job has been parallelized specifying autoFiles & autoNJobs in the config file , will launch a new job to automatically
                 concatenate all root output files from your parallelized jobs. To be done before get.
'"\n    ${RED}hadd_tweak ${DEF}"': Same as -hadd, but recompiles hadd.cxx code with your libraries. Useful for instance to merge TOperation objects. 
                 Need to provide details of classes to hadd in config/btask.conf.
'"\n    ${RED}get ${DEF}"'       : Will retrieve for all finished tasks all outputs specified in outList and put them in outDir . 
                 Files will have name : myfilename_taskname_tag_jobid.extension. Will clean by default the tasks.
                 ('${CYAN}-noremame${DEF}'   : skip adding _taskname_tag to myfilename)
                 ('${CYAN}-nojobid${DEF}'    : skip adding _jobid number to myfilename)
                 ('${CYAN}-local_hadd${DEF}' : will perform an hadd on files after the get [for now works only if just 1 output root file] )
'"\n    ${RED}kill ${DEF}"'      : Will kill all jobs.
'"\n    ${CYAN}t/task ${DEF}"'    : (optional) jointly used with -status , -resubmit , -hadd , -get , -kill , will execute the option only for the given task. 
'"\n    ${CYAN}def ${DEF}"'       : (optional) will answer by default to questions. Takes y [for yes] or n [for no] as parameter 
'`



# ---------------------------- Variables ---------------------------------------

declare -a vJobID
statusVerbose=0
sourceroot_command='source /localgrid/xjanssen/root_5.26.00e_iihe_default_dcap/root/bin/thisroot.sh'
pnfsdir="/pnfs/iihe/cms/store/user/$USER/"


btask_config=`dirname $0`'/../config/btask.conf'
workdir=$HOME'/'`( cat $btask_config | grep workdir | awk '{print $2}' )`
if [ ! -d $workdir ] ; then
  mkdir -p $workdir 
fi
dbdir=$HOME'/'`( cat $btask_config | grep jobdbdir | awk '{print $2}' )`
if [ ! -d $dbdir ] ; then
  mkdir -p $dbdir
fi
ongodb=$dbdir'/'`( cat $btask_config | grep ongoing_db | awk '{print $2}' )`
if [ ! -f $ongodb ];then
  touch $ongodb
  echo -e "${CYAN}[btask] WARNING :${DEF} No ongoingjob.db file -> void file created !!!!!"
fi
donedb=$dbdir'/'`( cat $btask_config | grep donejob_db | awk '{print $2}' )`
if [ ! -f $donedb ];then
  echo -e "${CYAN}[btask] WARNING :${DEF} No finishedjob.db file -> void file created !!!!!"
  touch $donedb
fi


if [ `uname -a | grep 'iihe.ac.be' | wc -l` -eq 1 ];then
  sdbdir=$(eval echo $( cat $btask_config | grep sandboxdiriihe | awk '{print $2}' ))
fi
if [ `uname -a | grep 'cern.ch' | wc -l` -eq 1 ];then
  sdbdir=$(eval echo $( cat $btask_config | grep sandboxdircern | awk '{print $2}' ))
fi

hadd_code=$(eval echo $( cat $btask_config | grep hadd_code | awk '{print $2}' ))
hadd_dir="`cat $btask_config | grep hadd_dir | sed 's:hadd_dir::'`"
hadd_inc="`cat $btask_config | grep hadd_inc | sed 's:hadd_inc::'`"
hadd_src="`cat $btask_config | grep hadd_src | sed 's:hadd_src::'`"


# ---------------------------- Functions ---------------------------------------

Usage()
{
  echo "$Manual" ; exit ;
}

UsageCfg()
{
  echo "Missing some inputs in cfg file ! "; print_config ; exit ;
}


#################################################################################################################################
print_config()
{
  echo "taskName   = "$taskName
  echo "queueName  = "$queueName
  echo "inDir      = "$inDir   
  echo "inList     = "$inList  
  echo "outDir     = "$outDir   
  echo "outList    = "$outList 
  echo "execBase   = "$execBase
  echo "execMult   = "$execMult

#  if [  $autoON -ne 0 ];then
#    echo "autoFiles           = $autoFiles"

#    if [ $autoNJobs -ne 0 ];then
#      echo "autoNJobs           = $autoNJobs"
#    else
#      echo "autoNfiles_per_jobs = $autoNfiles_per_jobs"
#    fi
#  fi
}

#################################################################################################################################
parse_config()
{
  if [ ! -f $cfg ];then
    echo -e "${RED}[btask] ERROR :${DEF} The config file $cfg you specified doesn't exist !"
    exit
  fi

  #echo "--> Parsing cfg file: "$cfg
  MultipleJobs=1
  grep taskName  $cfg -q && taskName=`( cat $cfg | grep taskName  | awk -F'=' '{print $2}' | sed "s: ::g")` || UsageCfg
  grep queueName $cfg -q && queueName=`(cat $cfg | grep queueName | awk -F'=' '{print $2}' | sed "s: ::g")` || echo '[btask] INFO : Using default : '$queueName
  grep inDir     $cfg -q && inDir=`(    cat $cfg | grep inDir     | awk -F'=' '{print $2}' | sed "s: ::g")` || UsageCfg
  grep inList    $cfg -q && inList=`(   cat $cfg | grep inList    | awk -F'=' '{print $2}'               )` || UsageCfg
  grep outDir    $cfg -q && outDir=`(   cat $cfg | grep outDir    | awk -F'=' '{print $2}' | sed "s: ::g")` || UsageCfg
  grep outList   $cfg -q && outList=`(  cat $cfg | grep outList   | awk -F'=' '{print $2}'               )` || UsageCfg
  grep execBase  $cfg -q && execBase=`( cat $cfg | grep execBase  | awk -F'=' '{print $2}'               )` || UsageCfg
  grep execMult  $cfg -q && execMult=`(cat $cfg  | grep execMult  | awk -F'=' '{print $2}'               )` || MultipleJobs=0
 
  #auto Variables
  grep autoFiles $cfg -q && autoFiles=`(cat $cfg | grep autoFiles | awk -F"=" '{print $2}'               )` || autoFiles=0
  grep autoNJobs $cfg -q && autoNJobs=`(cat $cfg | grep autoNJobs | awk -F"=" '{print $2}'               )` || autoNJobs=0
  grep autoNfiles_per_jobs $cfg -q && autoNfiles_per_jobs=`(cat $cfg | grep autoNfiles_per_jobs | awk -F"=" '{print $2}' )` || autoNfiles_per_jobs=0
  #grep autoFileManagerArgs $cfg -q && autoFileManagerArgs=`(cat $cfg | grep autoFileManagerArgs | awk -F"=" '{print $2}'               )` || autoNJobs=0
  #print_config
  
  return 1
}

#################################################################################################################################
check_config()
{
  autoON=0
  if [ "$autoFiles" != "0" ];then
    autoON=1
  fi
  
  if [ $autoNJobs -ne 0 ] && [ $autoNfiles_per_jobs -ne 0 ];then
    echo -e "${RED}[btask] ERROR :${DEF} You need to specify only one of autoNJobs & autoNfiles_per_jobs."
    exit
  fi
  
  if [ $autoNJobs -ne 0 ] || [ $autoNfiles_per_jobs -ne 0 ];then
    if [ $autoON -eq 0 ];then
      echo -e "${RED}[btask] ERROR :${DEF} You need to specify autoFiles if you want to parallelize your jobs."
      exit
    fi
  fi

  #Checking if more than 1 job in execMult when autoON is on
  if [ $MultipleJobs -gt 0 ] && [ $autoON -gt 0 ];then
    if [ `echo $execMult|grep ';' -c` -gt 0 ];then
      echo -e "${RED}[btask] ERROR :${DEF} autoFile is on : you must have at most 1 job in execMult ( or you left a \";\"  at the end ? ) . Exiting ..."
      exit ;
    fi  
  fi
}

#################################################################################################################################
mkdir_task(){
  taskID=`(mktemp -p $workdir -t .XXX | awk -F'.' '{print $2}')`
  taskTag=$tag
  if [ "$tag" == "NULL" ] ; then 
    taskTag=$taskID
  fi
  
  if [ `is_in_db $taskName $taskTag` -eq 1 ];then
    echo -e "${RED}[btask] ERROR :${DEF} A task with tag ${YEL}$taskTag${DEF} already exists. Please specify another tag, or remove the -tag option, or kill the existing task."
    exit
  fi
  
  taskDir=$workdir/$taskName'_'$taskID
  taskSdb=$sdbdir/$taskName'_'$taskID
  mkdir -p $taskDir
  mkdir -p $taskSdb
}

#################################################################################################################################
get_specific_task(){
  if [ "$taskname" == "NULL" ] ; then
    echo -e "${RED}[btask] ERROR :${DEF} Please specify a task name using -task <taskname>"
    exit
  else
    job=$( cat $ongodb |sed 's: :#:g'| grep "$taskname#"|sed 's:#: :g')  
  fi
  
  if [ -z "$job" ] ; then
    echo -e "${RED}[btask] ERROR :${DEF} Task $taskname not found."
    exit
  fi
  
  # Check if job is done
  get_para_from_db
  is_task_finished
  if [ $resubmit -eq 0 ] ; then
    if [ `get_task_status` -eq 0 ] ; then
      exit
    fi
  fi
}

#################################################################################################################################
get_tasks(){
  if [ "$taskname" == "NULL" ] ; then
    joblist=`( cat $ongodb | sed "s: :;:g")` 
  else
    joblist=$( cat $ongodb | sed "s: :;:g "| grep "`echo $taskname|sed 's:#:;:'`")  
  fi
  
  if [ -z "$joblist" ] ; then
    echo -e "${GREEN}[btask] INFO :${DEF} No active task"
    exit
  fi
}

#################################################################################################################################
print_status(){
  if [ "$LABO" == "IIHE" ] ; then
    echo -e "${BLUE}#CPU      Free    Total Jobs      Running Waiting ComputingElement${DEF}    "
    echo -e "----------------------------------------------------------------------"
    lcg-infosites --vo cms ce | grep "cream01.iihe.ac.be"
    echo -e "######################################################################"
  fi
  get_tasks
    
  if [ "$LABO" == "IIHE" ] ; then
    echo -e "${BLUE}Job ID  	     Username Queue    Jobname  	SessID NDS   TSK Memory Time  S Time${DEF} "
    echo -e "-------------------- -------- -------- ---------------- ------ ----- --- ------ ----- - -----"
  fi 
  if [ "$LABO" == "CERN" ] ; then
    echo -e "${BLUE}JOBID     USER    STAT  QUEUE      FROM_HOST   EXEC_HOST   JOB_NAME   SUBMIT_TIME${DEF} "
    echo -e "----------------------------------------------------------------------------------"
  fi
 
  for job in $joblist ; do
    job=`echo $job | sed "s:;: :g"`
    get_para_from_db
    print_task_status
  done
}

#################################################################################################################################
set_qstat(){
    if [ "$LABO" == "IIHE" ] ; then
      QSTAT=$(echo "qstat -u $USER $queueName") 
    fi
    if [ "$LABO" == "CERN" ] ; then
      QSTAT=$(echo "bjobs")
    fi
}

#################################################################################################################################
print_task_status(){
  echo -e "-------------------------  ${BLUE}$taskFullName${DEF}  ----------------------------"
  
  for i in `seq 0 $( expr $nJobs - 1 )` ; do
    set_qstat
    res=`( $QSTAT 2>/dev/null | grep  ' '"${taskids[$i]}"' ')`   
    case `get_job_status` in
      -2 ) echo -e "${RED}$res${DEF}"  ; continue ;;
      -1 ) echo -e "${YEL}$res${DEF}"  ; continue ;;
       0 ) COL=${RED}   ;;
       1 ) COL=${GREEN} ;;
    esac
    
    testFile="${sandboxes[$i]}OutputSandbox.tgz"
    res=`(ls $testFile 2>&1)`
    if [ $pnfs -eq 0 ];then
      echo -e "${COL}${taskids[$i]} DONE${DEF} -> File: "$res
    else
      echo -e "${COL}${taskids[$i]} DONE${DEF} -> File on pnfs: "`ls $pnfsdir${sandboxes[$i]} 2>&1`
    fi
      
  done
}


#################################################################################################################################
print_status_fast(){
  
  get_tasks
    
  #echo -e "${BLUE}taskName \t\t ${GREEN}nFinished \t ${RED}nCrashed \t ${YEL}nRunning \t ${CYAN}nQueued${DEF}"
  printf "${BLUE}%-27s ${GREEN}%-10s  ${RED}%-10s  ${YEL}%-10s  ${CYAN}%-10s ${DEF} %s \n" "taskFullName" "Finished" "Crashed" "Running" "Queued" "Total"
  
  for job in $joblist ; do
    job=`echo $job | sed "s:;: :g"`
    get_para_from_db
    print_task_status_fast
  done
}

#################################################################################################################################
print_task_status_fast(){
  n_finished=0
  n_crashed=0
  n_running=0
  n_queued=0
  
  for i in `seq 0 $( expr $nJobs - 1 )` ; do
    case `get_job_status` in
      -2 ) n_queued=`expr $n_queued + 1`     ;;
      -1 ) n_running=`expr $n_running + 1`   ;;
       0 ) n_crashed=`expr $n_crashed + 1`   ;;
       1 ) n_finished=`expr $n_finished + 1` ;;
    esac
  done
  #echo -e "${BLUE}%30$taskFullName${DEF} \t\t ${GREEN}$n_finished/$nJobs \t ${RED}$n_crashed/$nJobs \t ${YEL}$n_running/$nJobs \t ${CYAN}$n_queued/$nJobs ${DEF}"
  if [ $bw -eq 1 ] ; then
    printf "%-30s %-10s  %-10s  %-10s  %-9s  %s \n" "$taskFullName" "$n_finished" "$n_crashed" "$n_running" "$n_queued" "$nJobs"
  else
     printf "${BLUE}%-30s ${GREEN}%-10s  ${RED}%-10s  ${YEL}%-10s  ${CYAN}%-9s  ${DEF}%s \n" "$taskFullName" "$n_finished" "$n_crashed" "$n_running" "$n_queued" "$nJobs"
  fi
  #printf "${BLUE}%30$taskFullName${DEF} \t\t ${GREEN}$n_finished/$nJobs \t ${RED}$n_crashed/$nJobs \t ${YEL}$n_running/$nJobs \t ${CYAN}$n_queued/$nJobs ${DEF}"
}


#################################################################################################################################
get_task_status(){
  ALLJOBDONE=1
  set_qstat
  for i in `seq 0 $( expr $nJobs - 1 )` ; do
    res=`($QSTAT 2>/dev/null | grep  ' '"${taskids[$i]}"' ')` 
    if [ ! -z "$res" ]; then
      ALLJOBDONE=0
    fi
  done
  echo $ALLJOBDONE
}


#################################################################################################################################
get_job_status(){
  set_qstat
  res=`($QSTAT 2>/dev/null | grep  ' '"${taskids[$i]}"' ')` 
  if [ ! -z "$res" ]; then
    if [ "$LABO" == "IIHE" ] ; then
      PEND='Q'
    fi
    if [ "$LABO" == "CERN" ] ; then
      PEND='PEND' 
    fi
    if [ `echo $res|grep -e " $PEND " -c` -eq 1 ];then
      echo -e "-2"
    else
      echo -e "-1"
    fi
  else
    testFile="${sandboxes[$i]}OutputSandbox.tgz"
    res=`(ls $testFile 2>&1)`
    if [ $pnfs -eq 0 ];then
      if [ -f $testFile ] && [ `tar tzf $testFile|wc -l` -gt 0 ];then
        echo -e "1"
      else
        echo -e "0"
      fi
    else
      if [ ! -d $pnfsdir${sandboxes[$i]} ] || [ `ls $pnfsdir${sandboxes[$i]}|wc -l` -eq 0 ];then
        echo -e "0"
      else
        echo -e "1"
      fi
    fi
  fi
}

#################################################################################################################################
is_task_finished(){
  echo -e "\n${GREEN}[btask] INFO :${DEF} Checking task: "$taskFullName
  if [ `get_task_status` -eq 0 ] ; then
    echo -e "${RED}[btask] ERROR :${DEF} Not all jobs are done for task: "$taskFullName
  fi
}

#################################################################################################################################
is_in_db(){
  echo `cat $ongodb | grep "$1 $2" -c`
}

#################################################################################################################################
get_para_from_db(){
  taskName=`echo $job|awk '{print $1}'`
  taskTag=`echo $job|awk '{print $2}'`
  taskId=`echo $job|awk '{print $3}'`
  taskFullName=`echo $taskName"#"$taskTag`
  nJobs=`echo $job|awk '{print $4}'`
  pnfs=`echo $job|awk '{print $5}'`
  
  taskDir=$workdir/$taskName'_'$taskId
  taskSdb=$sdbdir/$taskName'_'$taskId
  
  cfg=$taskDir/$taskName.cfg
  parse_config
  
  #making list of sandboxes & taskids
  #declare -a sandboxes
  #declare -a taskids
  sandboxes=( '' )
  taskids=( '' )
  for i in `seq 1 $nJobs`;do
    sandboxes=( `echo "${sandboxes[*]}" "$taskSdb/Sandbox_$taskId"_"$i/"` )
    taskids=( `echo "${taskids[@]}" "$taskId""_""$i"` )
  done
}


#################################################################################################################################
add_task_to_db(){
  cp /dev/null $taskDir/$taskName.cfg
  print_config >> $taskDir/$taskName.cfg
  echo $taskName' '$taskTag' '$taskID'  '${#vJobID[@]}' '$pnfs >> $ongodb
  echo -e "${GREEN}[btask] INFO :${DEF} The following task has been started: $taskName#$taskTag"
  echo -e "${GREEN}[btask] INFO :${DEF} composed of subtask : ${YEL}${vJobID[@]}${DEF}"
}


#################################################################################################################################
remove_task_from_db(){
  echo -e "${GREEN}[btask] INFO :${DEF} Removing task: "$taskFullName
  cat $ongodb | grep    "$taskName $taskTag $taskId" >> $donedb 
  tmpFile=`(mktemp)`
  cat $ongodb | grep -v "$taskName $taskTag $taskId" >> $tmpFile
  mv  $tmpFile $ongodb
}

#################################################################################################################################
make_autofilelist(){

  if [ $autoON -eq 0 ];then
    return 
  fi

  
  if [ `echo $autoFiles|grep ".txt" -c` -eq 1 ];then
    autodir=''
    autolist=`cat $inDir'/'$(echo $autoFiles|sed "s# ##")`
    echo -e "${GREEN}[btask] INFO :${DEF} Input is a txt file"
  else
    
    if [ -d `echo $autoFiles|awk '{print $1}'` ];then
      autodir=$autoFiles
      autolist=`ls -d $autoFiles/*`
      echo -e "${GREEN}[btask] INFO :${DEF} Input is a directory"
    else
      autodir=''
      autolist=`ls -d $autoFiles`
      echo -e "${GREEN}[btask] INFO :${DEF} Input is a list of files"
    fi
  fi
  rm -fr $taskDir/filelist_[0-9].txt

  nfiles=`echo $autolist|sed "s# #\n#g"|wc -l`
  #echo '[btask] INFO : Number of files to divide :' $nfiles
  #echo '[btask] INFO : Number of Jobs to do :' $autoNJobs
  if [ $autoNJobs -gt $nfiles ];then
    autoNJobs=$nfiles
  fi
  files_per_jobs=`expr $nfiles / $autoNJobs`
  #echo '[btask] INFO : Files per Jobs : ' $files_per_jobs
  
  
  echo -e "${GREEN}[btask] INFO :${DEF} Will create automatically $autoNJobs(+1?) jobs with $files_per_jobs files per jobs for a total of $nfiles files."
  echo -e '               Your code needs to take filelist.txt as input , which is automatically created in "inDir" and added to "inList"'
  echo -e '               If filelist.txt already exists in "inDir"  , it will first be moved, and then restored at the end of the job'
  
  

  nfile_injob=0
  ijob=0
  for autofile in $autolist;do
    if [ `echo $autofile|grep "pnfs" -c` -gt 0 ];then
      if [ `echo $autofile|grep -v 'dcap:///' -c` -gt 0 ];then
        autofile="dcap://$autofile"
      fi
    fi
  
    let nfile_injob=$nfile_injob+1
  
    if [ $nfile_injob -gt $files_per_jobs ];then
      nfile_injob=1
      let ijob=$ijob+1
    fi
  
    #creating filelist i
    if [ ! -f $taskDir/filelist_$ijob.txt ];then
      cp /dev/null $taskDir/filelist_$ijob.txt
    fi
  
    echo $autofile >> $taskDir/filelist_$ijob.txt
  done
  
  #cd $autoCurrentDir
 
  if [ $MultipleJobs -eq 0 ] ;then
    execMult='echo '
    MultipleJobs=1
  fi
  execMultBase=$execMult
  for iExec in `seq 1 $ijob`;do
    execMult="$execMult ; $execMultBase"
  done
  
  
}

#################################################################################################################################
hadd_all(){
  get_tasks
  for job in $joblist ; do
    job=`echo $job | sed "s:;: :g"`
    get_para_from_db
    
    #skip hadd jobs
    if [ `echo $taskFullName|grep hadd -c` -eq 1 ];then
      continue
    fi
    
    echo -e "\n------------------------- ${BLUE}$taskFullName${DEF}  ----------------------------"
    taskname=$taskFullName
    
    make_hadd_job
  done
}





#################################################################################################################################
make_hadd_job(){

  get_specific_task
  
  if [ `is_in_db $taskName hadd_$taskTag` -eq 1 ];then
    echo -e "${CYAN}[btask] WARNING :${DEF} Task ${YEL}$taskName#hadd_$taskTag${DEF} already exists. Please kill this hadd job before re-running it."
    return
  fi 
    
  outputfiles=( '' )
  tarFile="OutputSandbox.tgz"  
  
  # Loop over SandBoxes and untar
  missingoutputs=0
  for i in `seq 0 $( expr $nJobs - 1 )` ; do

    cd ${sandboxes[$i]}
    
    #checking if $tarFile is present
    if [[ ! -f $tarFile && $pnfs -eq 0 ]] || [[ $pnfs -gt 0  && `ls $pnfsdir${sandboxes[$i]}|wc -l` -eq 0 ]] ;then
      echo -e "${CYAN}[btask] WARNING :${DEF} No output files were present for job "${taskids[$i]}
      missingoutputs=1
      continue
    fi
    
    # Unpack tar file
    if [ $pnfs -eq 0 ] ;then
      tar xzf $tarFile
    fi
    
    #keeping the number of a sandbox with output files
    goodSb=$i
    
  done
  
  if [ $missingoutputs -gt 0 ];then
    echo -e "${GREEN}[btask] INFO :${DEF} You should try to resubmit the task with btask -resubmit -task "$taskFullName
    echo -en "        ==> Do you want to continue with the hadd job ? [y/n] [default=y]  "
    if [ $def -eq 0 ];then read a ; else echo "$answer" ; a="$answer"; fi
    case $a in n ) return ;; esac
  fi
  
  #making list of output files
  outputfiles=''
  if [ $pnfs -eq 0 ] ;then
    fileList=`(tar tzf ${sandboxes[$goodSb]}/$tarFile)`
  else
    fileList=`ls $pnfsdir${sandboxes[$goodSb]}`
  fi
  
  for file in $fileList ; do
    #if [ `file $file|grep 'ROOT' -c` -eq 1 ];then  #can't use it on pnfs ...
    if [ `echo $file|grep '.root' -c` -eq 1 ];then
      outputfiles=( `echo "${outputfiles[@]}" "$file"` )
    fi
  done
  
  echo "N :${outputfiles}:"
  
  if [ "${outputfiles}" == '' ];then
    echo -e "${CYAN}[btask] WARNING :${DEF} no root ouput files were created by the job. Nothing to hadd ..."
    return 
  fi
  
  echo -e "${GREEN}[btask] INFO :${DEF} Will run ${#outputfiles[@]} hadd subjobs on the ${#outputfiles[@]} following output files :"
  echo -e "               ${outputfiles[@]}"
  
  
  #making path to execute
  execmult='ff'
  haddOutFiles=''
  ihaddOutFiles=0
  makeDIR=''
  imakeDIR=0
  HADD="hadd"
  if [ $hadd_tweak -eq 1 ];then
    HADD="./hadd_tweak"
  fi
  
  for iOutputFile in ${outputfiles[@]};do
    #hadd_command='hadd -f '${iOutputFile%.root}'_'$taskId'.root'
    hadd_command="$HADD -f "$iOutputFile
    
    #################### FIXME
    #  Xavier Stuff ==> Surely not needed when -pnfs
    if [ $ihaddOutFiles == 0 ] ; then
      haddOutFiles=$iOutputFile
      ihaddOutFiles=1
    else
      haddOutFiles=$haddOutFiles' , '$iOutputFile
    fi  
    if [ ! -z "$(echo $iOutputFile | sed -n 's:\([/]\):\1:p')" ]; then
      DIR=`(echo $iOutputFile | awk '{split($0,a,"/") ; n=0 ; for (i in a) n++ ; for (i=1; i<n; i++) printf a[i]"/" }')`
      makeDIR=$makeDIR' ; mkdir -p '$DIR
    fi
    ####################
    
    for iSandBox in ${sandboxes[@]};do
      if [[ ! -f $iSandBox/$iOutputFile && -f $iSandBox/$tarFile && $pnfs -eq 0 ]] || [[ $pnfs -gt 0 && ! -f $pnfsdir$iSandBox/$iOutputFile ]] ;then
        echo -e "${CYAN}[btask] WARNING :${DEF} subjob managed to retrieve output, but problem arrised when untaring "$iOutputFile' from '$iSandBox
	echo -e "                  Will not run hadd on this subjob"
	echo -en "        ==> Do you want to continue with the hadd job ? [y/n] [default=y]  "
        if [ $def -eq 0 ];then read a ; else echo "$answer" ; a="$answer"; fi
        case $a in n ) return ;; esac
	continue
      fi
      
      if [ $pnfs -eq 0 ] ;then
        hadd_command=`echo $hadd_command $iSandBox/$iOutputFile`   
      else
        hadd_command=`echo $hadd_command dcap://$pnfsdir$iSandBox/$iOutputFile`
      fi
       
    done
    
    execmult=`echo $execmult" ; "$hadd_command`
  done

  inDir_hadd="`pwd`"
  inList_hadd="conf_$taskId.txt"
  execBase_hadd="$sourceroot_command $makeDIR"
  if [ $hadd_tweak -eq 1 ];then
    inDir_hadd="$hadd_dir"
    cd $inDir_hadd
    make_hadd_code $btask_config
    inList_hadd='hadd_tweak.cxx , makeHadd.sh , haddLinkDef.h , '`echo $hadd_src $hadd_inc|sed 's: :,:g'`
    execBase_hadd="$sourceroot_command $makeDIR ;  ./makeHadd.sh -dic -lib -hadd"
    cp $hadd_code $inDir_hadd/.
  fi
  
  
  #making temp conf file
  cp /dev/null conf_$taskTag.txt
  echo 'taskName = '`echo $taskName`			>> conf_$taskTag.txt
  echo 'inDir    = '$inDir_hadd				>> conf_$taskTag.txt
  echo 'inList   = '$inList_hadd			>> conf_$taskTag.txt
  echo 'outDir   = '$outDir				>> conf_$taskTag.txt
# echo 'outList  = "*.root"'				>> conf_$taskTag.txt
  echo 'outList  = '$haddOutFiles                       >> conf_$taskTag.txt
  echo 'execBase = '$execBase_hadd			>> conf_$taskTag.txt
  echo 'execMult = '`echo $execmult|sed "s#ff ;##"`	>> conf_$taskTag.txt
  
  if [ "$execmult" == "ff" ];then
    echo -e "${RED}[btask] ERROR :${DEF} Did not manage to make proper hadd command. See config below:"
    echo -e "--------------"
    cat conf_$taskTag.txt
    echo -e "--------------"
    return
  fi
  
  
  
  echo -e "\n${GREEN}[btask] INFO :${DEF} Launching hadd job hadd_$taskTag"
  echo -e "==========================================================================================\n"
  
  btask -submit conf_$taskTag.txt -tag "hadd_$taskTag"
  #cat conf_$taskTag.txt
}




#################################################################################################################################
submit_jobs(){

  #saving existing filelist, to restore after jobs are launched
  if [ -f $inDir/filelist.txt ] && [ $autoNJobs -ne 0 ];then
    #echo "Moving existing $inDir/filelist.txt in /tmp/filelist_$taskID"
    mv $inDir/filelist.txt /tmp/filelist_$taskID
  fi

  SUBMIT="subjob --sdbdir $taskSdb --inDir $inDir --outList $outList --qname $queueName --wtime$wtime" 
  
  if [ $pnfs -gt 0 ];then
    SUBMIT=`echo "$SUBMIT --pnfs"`
  fi
  
  iJob=0

  if [ $MultipleJobs -eq 0 ] ; then 
    iJob=`expr $iJob + 1`
    echo $execBase
    #JOB=`echo $execBase' --jobid '$taskID'_'$iJob '--inList '$inList`
    JOB=`echo '--jobid '$taskID'_'$iJob' --exec '$execBase '--inList' $inList`
    JobID=`($SUBMIT $JOB | grep JobID | awk -F":" '{print $2}' | sed "s: ::g")`
    vJobID[$[${#vJobID[@]}+1]]=$JobID

  else

    SaveIFS=$IFS
    IFS=';' read -ra JOBS <<< "$execMult"
    for j in "${JOBS[@]}"; do
      if [ $autoNJobs -gt 0 ];then
        cp $taskDir/filelist_$iJob.txt $inDir/filelist.txt
	inList=`echo "$inList filelist.txt"`
      fi
      iJob=`expr $iJob + 1`
      JOB=`echo '--jobid '$taskID'_'$iJob' --exec '$execBase ' ; ' $j '--inList' $inList`
      JobID=`($SUBMIT $JOB | grep JobID | awk -F":" '{print $2}' | sed "s: ::g")`
      vJobID[$[${#vJobID[@]}+1]]=$JobID
    done
    IFS=$SaveIFS

  fi
  
  #restoring previously saved filelist.txt
  if [ -f /tmp/filelist_$taskID ];then
    mv /tmp/filelist_$taskID $inDir/filelist.txt
  fi
}


#################################################################################################################################
kill_jobs(){

  get_tasks

  for job in $joblist ; do
    job=`echo $job | sed "s:;: :g"` 
    get_para_from_db
    
    echo -e "${GREEN}[btask] INFO :${DEF} Killing Task: "$taskFullName
    for i in `seq 0 $( expr $nJobs - 1 )`; do
      echo -e "${GREEN}[btask] INFO :${DEF} Killing SubTask: "${taskids[$i]}
      # Kill job (if still running)
      set_qstat
      res=`($QSTAT 2>/dev/null | grep ${taskids[$i]})` 
      if [ ! -z "$res" ]; then
        id=`(echo $res | awk '{print $1}' | awk -F'.' '{print $1}')`
        if [ "$LABO" == "IIHE" ] ; then
          qdel $id.cream01 
        elif [ "$LABO" == "CERN" ] ; then
          bkill $id
        fi
      fi
      
      # Remove SubTask SandBox
      rm -rf ${sandboxes[$i]}
      
    done
    
    # Remove Task SandBox
    rm -rf $taskSdb
    if [ $pnfs -eq 1 ];then
      rm -fr $pnfsdir$taskSdb
    fi
    
    
    # Remove Task form ongoing DB 
    remove_task_from_db


  done

} 

#################################################################################################################################
get_out(){

  get_tasks

  for job in $joblist ; do
    job=`echo $job | sed "s:;: :g"` 
    get_para_from_db
    
    # Check if job is done
    is_task_finished
    if [ `get_task_status` -eq 0 ];then
      continue
    fi
      
    echo -e "${GREEN}[btask] INFO :${DEF} Retrieving task: "$taskFullName 
    echo -e "	  ==> log files are in ${YEL}$taskDir${DEF}"
  
    # Go to outDir 
  
    cd $outDir
  
    tmpdir=$taskName'_'$taskId
    mkdir $tmpdir
    cd $tmpdir
  
    clean=1
    echo -en "${GREEN}[btask] INFO :${DEF} Do you want to clean this task ? [y/n] [default=y]  "
    if [ $def -eq 0 ];then read a ; else echo "$answer" ; a="$answer"; fi
    case $a in n ) clean=0 ;; esac
    
    nFilesToHadd=0
  
    # Loop over SandBoxes 
    for i in `seq 0 $( expr $nJobs - 1 )` ; do
      echo -e "${GREEN}[btask] INFO :${DEF} Retrieving task $taskFullName   , job ${taskids[$i]}" 
  
      if [ "$tag" == "NULL" ] ; then
        tagID=$taskTag
      else
        tagID=$tag
      fi

      tarFile=${sandboxes[$i]}"/OutputSandbox.tgz"
      
      #checking if $tarFile is present
      if [ ! -f $tarFile ] && [ $pnfs -eq 0 ];then
        echo -e "${CYAN}[btask] WARNING :${DEF} No output files were present for job "${taskids[$i]}
        continue
      else
        
        # Unpack tar file
        echo -e '  	==> output files :'
        
        if [ $pnfs -eq 0 ];then
          fileList=`(tar tzf $tarFile)`
        else
          fileList=`ls $pnfsdir${sandboxes[$i]}`
        fi
	
	nFilesToHadd=`echo $fileList|sed 's: :\n:g'|grep -c -e ".root"`
	
        for file in $fileList ; do
	
	  if [ $i -eq 0 ] && [ $nFilesToHadd -eq 1 ] && [ `echo $file|grep -e ".root"|wc -l` -eq 1 ];then
	    hadd_local_command="hadd -f ${file%.root}_${taskName}_$tagID.root"
	  fi
        
	
	  #making output file name
          test=`echo $file | (grep "\.")`
          if [ ! -z $test ] ; then
            first=`(echo  $file | awk '{split($0,a,"."); n=0 ; for (i in a) n++ ; nm1=n-1; for (i=1; i<nm1; i++) printf a[i]"." ; print a[nm1] }')`
            #middle=$taskName'_'$tagID'_'$i'.'
            middle=''
            if [ $norename -eq 0 ] ; then
              middle='_'$taskName'_'$tagID
            fi
            if [ $nojobid -eq 0 ] ; then
              middle=$middle'_'$i
            fi
            middle=$middle'.'
            last=`(echo  $file | awk '{split($0,a,"."); n=0 ; for (i in a) n++ ; print a[n]}')`
            outfile=$first$middle$last
          else
            #outfile=$file"_"$taskName'_'$tagID'_'$i
            outfile=$file
            if [ $norename -eq 0 ] ; then
              outfile=$outfile'_'$taskName'_'$tagID
            fi
            if [ $nojobid -eq 0 ] ; then
              outfile=$outfile'_'$i
            fi
          fi
          
	  #untaring/copying the files
          if [ $pnfs -eq 0 ];then
            tar xzf $tarFile $file 
            mv $file ../$outfile
          else
            dccp $pnfsdir${sandboxes[$i]}/$file ../$outfile &> /dev/null
          fi
        	     
          echo -e "		 ${YEL}$outDir/$outfile${DEF}"
	  hadd_local_command="$hadd_local_command "`echo $outDir/$outfile|grep '.root'`
        done
      fi
      
      
      
      # Copy logfiles
  
      errFileIn="${sandboxes[$i]}/stderr"
      outFileIn="${sandboxes[$i]}/stdout"
  
      errFileOut=$taskDir"/stderr_$i"
      outFileOut=$taskDir"/stdout_$i"
  
      cp $errFileIn* $errFileOut
      cp $outFileIn* $outFileOut
    
  
      # Remove SubTask SandBox
      if [ $clean -eq 1 ];then
        rm -rf ${sandboxes[$i]}
      fi
      
      
    done
    cd ..
    rm -rf $tmpdir 
    
    
    #LOCAL HADD (only if 1 file present)
    if [ $local_hadd -eq 1 ];then
      echo "nFilesToHadd: $nFilesToHadd"
      if [ $nFilesToHadd -ne 1 ];then
        echo -e "${CYAN}[btask] WARNING :${DEF} I can do a local hadd only if 1 output root file is present ! I'm not doing the hadd ..."
      else
        echo -e "${GREEN}[btask] INFO :${DEF} Doing a local hadd for task $taskFullName ..." 
        echo "($hadd_local_command)"
	$hadd_local_command  
      fi
    
    fi
    
    
    if [ $clean -eq 1 ];then
      # Remove Task SandBox
      rm -rf $taskSdb
      if [ $pnfs -eq 0 ];then
        rm -fr $pnfsdir$taskSdb
      fi
      
      # Remove Task form ongoing DB 
      remove_task_from_db
    fi
  
    
  done
  
}

#################################################################################################################################
resubmit(){

  get_specific_task
  
  tarFile="OutputSandbox.tgz"
  for i in `seq 0 $( expr $nJobs - 1 )` ; do
    cd ${sandboxes[$i]}
   
    #resubmit only if job is crashed
    if [ `get_job_status` -ne 0 ];then continue;fi
 
    echo -e "${CYAN}[btask] WARNING :${DEF} No output files were present for job "${taskids[$i]}
    echo -e "	  ==> resubmitting the job ${YEL}${taskids[$i]}${DEF}"
    if [ "$LABO" == "IIHE" ] ; then
      qsub -l walltime=$wtime -N ${taskids[$i]} -q $queueName -o `pwd`/stdout_retry -e `pwd`/stderr_retry qsub.sh > /dev/null
    elif [ "$LABO" == "CERN" ] ; then
      bsub -J ${taskids[$i]} -q $queueName -o `pwd`/stdout_retry -e `pwd`/stderr_retry qsub.sh > /dev/null
    fi
    
  done

}

#################################################################################################################################
resubmit_all(){

 get_tasks

  for job in $joblist ; do
    job=`echo $job | sed "s:;: :g"` 
    get_para_from_db
    
    echo -e "\n-------------------------  ${BLUE}$taskFullName${DEF}  ----------------------------"
    taskname=$taskFullName
    
    resubmit
  done
}


#################################################################################################################################

# ----------------------------  Parsing  Arguments  ----------------------------

submit=0
status=0
fast=0
def=0
answer="y"
getout=0
jkill=0
resubmit=0
addroot=0
hadd_tweak=0
local_hadd=0
tag="NULL"
taskname="NULL"
pnfs=0
norename=0
nojobid=0
bw=0
nothing=0

# time of jobs
wtime=35:59:00

for arg in $* ; do

  case $arg in
    -submit)      submit=1   ; option=$2   ; shift ; shift ;;
    -status)      status=1                         ; shift ;;
    -s)           status=1   ; fast=1              ; shift ;;
    -get)         getout=1                         ; shift ;;
    -kill)        jkill=1                          ; shift ;;
    -resubmit)    resubmit=1 			   ; shift ;;
    -hadd)        addroot=1  			   ; shift ;;
    -hadd_tweak)  addroot=1 ; hadd_tweak=1	   ; shift ;;
    -local_hadd)  local_hadd=1			   ; shift ;;
    -task)                    taskname=$2  ; shift ; shift ;;
    -t)                       taskname=$2  ; shift ; shift ;;
    -tag)                     tag=$2       ; shift ; shift ;;
    -pnfs)        pnfs=1 			   ; shift ;;
    -def)         def=1     ; answer=$2		   ; shift ;;
    -norename)    norename=1                       ; shift ;;
    -nojobid)     nojobid=1                        ; shift ;;   
    -bw)          bw=1                             ; shift ;;
    -wtime)       wtime=$2                 ; shift ; shift ;;
    -nothing)     nothing=1			   ; shift ;;
    -help)        Usage ;;
    *) ;;
  esac

done

# Check arguments (Only one action per command)

test=0
test=`expr $test + $submit`
test=`expr $test + $status`
test=`expr $test + $getout`
test=`expr $test + $jkill`
test=`expr $test + $resubmit`
test=`expr $test + $addroot`
test=`expr $test + $nothing`

if [ $test -eq 0 ] ; then
  echo -e "${RED}[btask] ERROR :${DEF} No valid arguments !"
  Usage
fi
if [ $test -gt 1 ] ; then
  echo -e "${RED}[btask] ERROR :${DEF} Can not do submit, status, get, resubmit, hadd at the same time !"
  Usage
fi

# ------------------------- SET LOCATION (CERN OR IIHE) -------------------------

if [ `uname -a | grep 'iihe.ac.be' | wc -l` -eq 1 ];then
  LABO='IIHE'
  queueName='localgrid@cream01'
else
  if [ `uname -a | grep 'cern.ch' | wc -l` -eq 1 ];then
    LABO='CERN'
    queueName='8nh'
  else
    echo "Warning , don't know were you are, correct before starting subjob."
    exit -1 
  fi
fi


# ------------------------  SUBMIT  JOB(S) --------------------------------------

if [ $submit -eq 1 ] ; then

  cfg=$option 
  parse_config
  check_config
  mkdir_task
  echo -e "${GREEN}[btask] INFO :${DEF} The following config will be used to start a task:"
  print_config
  make_autofilelist
  submit_jobs
  add_task_to_db

fi # end [ $submit -eq 1 ] 

# ------------------------  KILL JOB(S) -----------------------------------------

if [ $jkill  -eq 1 ] ; then

  kill_jobs

fi # end [ $jkill  -eq 1 ]

# ------------------------  RESUBMIT  JOB(S) ------------------------------------

if [ $resubmit -eq 1 ] ; then

  if [ "$taskname" == "NULL" ];then
    resubmit_all
  else
    resubmit
  fi

fi # end [ $resubmit -eq 1 ] 


# ------------------------  JOB(S) STATUS --------------------------------------

if [ $status -eq 1 ] ; then

  if [ $fast -eq 0 ];then
    print_status
  else
    print_status_fast
  fi

fi # end [ $status -eq 1 ]

# ------------------------  JOB(S) OUTPUT  RETRIEVAL  --------------------------

if [ $getout -eq 1 ] ; then

  get_out

fi # end [ $getout -eq 1 ] 

# ------------------------  JOB(S) OUTPUT  MERGE  ------------------------------

if [ $addroot -eq 1 ] ; then

  if [ "$taskname" == "NULL" ];then
    hadd_all
  else
    make_hadd_job
  fi
  
fi # end [ $addroot -eq 1 ]

if [ $nothing -eq 1 ]; then echo "Sourcing btask ..." ; fi
 
