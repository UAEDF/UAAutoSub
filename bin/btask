#!/bin/bash
#
########################################################################
#
# author:  Xavier Janssen                                08/03/2011
# purpose: Create and submit IIHE local job 
#          Full options !
#
########################################################################


### Usage:

Manual=$( cat <<SETVAR
 
 options: btask -submit <config>  : Submit job based on <config> file
          btask -status           : Get status of all jobs
          btask -get              : Retrieve output of all terminated jobs
          btask -kill             : Kill all jobs
                -tag  <tag>       : Replace the random job tag by <tag>
                                    Apply it together with -submit or -get
                -task <taskname>  : Adding to -status, -get or -hadd 
                                    restrict action to a single <taskname>
          btask -help             : Print this help message 

SETVAR
)

# btask -resubmit all     : Resubmit all jobs
# btask -resubmit <jobid> : Resubmit jobs <jobid> (comma separated list) 
# btask -hadd <taskname>  : Add all root files of a finished <taskname>
#                     -get will retrieve the added root file

# ---------------------------- Variables ---------------------------------------

declare -a vJobID
statusVerbose=0
sourceroot_command='source /localgrid/xjanssen/root_5.26.00e_iihe_default_dcap/root/bin/thisroot.sh'


btask_config=`dirname $0`'/../config/btask.conf'
workdir=$HOME'/'`( cat $btask_config | grep workdir | awk '{print $2}' )`
if [ ! -d $workdir ] ; then
  mkdir -p $workdir 
fi
dbdir=$HOME'/'`( cat $btask_config | grep jobdbdir | awk '{print $2}' )`
if [ ! -d $dbdir ] ; then
  mkdir -p $dbdir
fi
ongodb=$dbdir'/'`( cat $btask_config | grep ongoing_db | awk '{print $2}' )`
if [ ! -f $ongodb ];then
  touch $ongodb
  echo '[btask] Warning : No ongoingjob.db file -> void file created !!!!!'
fi
donedb=$dbdir'/'`( cat $btask_config | grep donejob_db | awk '{print $2}' )`
if [ ! -f $donedb ];then
  echo '[btask] Warning : No finishedjob.db file -> void file created !!!!!'
  touch $donedb
fi

sdbdir=$(eval echo $( cat $btask_config | grep sandboxdir | awk '{print $2}' ))


# ---------------------------- Functions ---------------------------------------

Usage()
{
  echo "$Manual" ; exit ;
}

UsageCfg()
{
  echo "Missing some inputs in cfg file ! "; print_config ; exit ;
}


print_config()
{
  echo "taskName   = "$taskName
  echo "inDir      = "$inDir   
  echo "inList     = "$inList  
  echo "outDir     = "$outDir   
  echo "outList    = "$outList 
  echo "execBase   = "$execBase
  echo "execMult   = "$execMult
  if [ $autoNJobs != 0 ];then
    echo "autoFiles   = $autoFiles"
    echo "autoNJobs   = $autoNJobs"
  fi
}

parse_config()
{
  #echo "--> Parsing cfg file: "$cfg
  MultipleJobs=1
  grep taskName  $cfg -q && taskName=`( cat $cfg | grep taskName  | awk -F"=" '{print $2}' | sed "s: ::g")` || UsageCfg
  grep inDir     $cfg -q && inDir=`(    cat $cfg | grep inDir     | awk -F"=" '{print $2}'               )` || UsageCfg
  grep inList    $cfg -q && inList=`(   cat $cfg | grep inList    | awk -F"=" '{print $2}'               )` || UsageCfg
  grep outDir    $cfg -q && outDir=`(   cat $cfg | grep outDir    | awk -F"=" '{print $2}'               )` || UsageCfg
  grep outList   $cfg -q && outList=`(  cat $cfg | grep outList   | awk -F"=" '{print $2}'               )` || UsageCfg
  grep execBase  $cfg -q && execBase=`( cat $cfg | grep execBase  | awk -F"=" '{print $2}'               )` || UsageCfg
  grep execMult  $cfg -q && execMult=`(cat $cfg  | grep execMult  | awk -F"=" '{print $2}'               )` || MultipleJobs=0
  grep autoFiles $cfg -q && autoFiles=`(cat $cfg | grep autoFiles | awk -F"=" '{print $2}'               )` || autoNJobs=0
  grep autoNJobs $cfg -q && autoNJobs=`(cat $cfg | grep autoNJobs | awk -F"=" '{print $2}'               )` || autoNJobs=0
  #grep autoTxt   $cfg -q && autoTxt=`(cat $cfg   | grep autoTxt   | awk -F"=" '{print $2}'               )` || autoNJobs=0
  #grep autoFileManagerArgs $cfg -q && autoFileManagerArgs=`(cat $cfg | grep autoFileManagerArgs | awk -F"=" '{print $2}'               )` || autoNJobs=0
  #print_config
  return 1
}

check_config()
{

  #Checking if more than 1 job in execMult when autoNJobs is on
  if [ $MultipleJobs -gt 0 ] && [ $autoNJobs -gt 0 ];then
    if [ `echo $execMult|grep ';' -c` -gt 0 ];then
      echo "[btask] Error : autoFile is on : you must have at most 1 job in execMult ( or you left a \";\"  at the end ? ) . Exiting ..."
      exit ;
    fi  
  fi
}

mkdir_task(){
  if [ "$tag" == "NULL" ] ; then 
    taskID=`(mktemp -p $workdir -t .XXX | awk -F'.' '{print $2}')`
  else
    taskID=$tag
  fi 
  taskDir=$workdir/$taskName'_'$taskID
  taskSdb=$sdbdir/$taskName'_'$taskID
  mkdir -p $taskDir
  mkdir -p $taskSdb
}

make_autofilelist(){

  if [ $autoNJobs -eq 0 ];then
    return 
  fi

  
  if [ `echo $autoFiles|grep ".txt" -c` -eq 1 ];then
    autodir=''
    autolist=`cat $inDir$(echo $autoFiles|sed "s# ##")`
    echo '[btask] INFO : Input is a txt file'
  else
    
    if [ -d `echo $autoFiles|awk '{print $1}'` ];then
      autodir=$autoFiles
      autolist=`ls -d $autoFiles/*`
      echo '[btask] INFO : Input is a directory'
    else
      autodir=''
      autolist=`ls -d $autoFiles`
      echo '[btask] INFO : Input is a list of files'
    fi
  fi
  rm -fr $taskDir/filelist_[0-9].txt
  
  nfiles=`echo $autolist|sed "s# #\n#g"|wc -l`
  #echo '[btask] INFO : Number of files to divide :' $nfiles
  #echo '[btask] INFO : Number of Jobs to do :' $autoNJobs
  files_per_jobs=`expr $nfiles / $autoNJobs`
  #echo '[btask] INFO : Files per Jobs : ' $files_per_jobs
  if [ $autoNJobs -gt $nfiles ];then
    autoNJobs=$nfiles
  fi
  
  
  echo '[btask] INFO : Will create automatically '$autoNJobs'(+1?) jobs with '$files_per_jobs' files per jobs'
  echo '               Your code needs to take filelist.txt as input , which is automatically created in "inDir" and added to "inList"'
  echo '               If filelist.txt already exists in "inDir"  , it will first be moved, and then restored at the end of the job'
  
  

  nfile_injob=0
  ijob=0
  for autofile in $autolist;do
    if [ `echo $autofile|grep "pnfs" -c` -gt 0 ];then
      if [ `echo $autofile|grep -v 'dcap:///' -c` -gt 0 ];then
        autofile="dcap://$autofile"
      fi
    fi
  
    let nfile_injob=$nfile_injob+1
  
    if [ $nfile_injob -gt $files_per_jobs ];then
      nfile_injob=1
      let ijob=$ijob+1
    fi
  
    #creating filelist i
    if [ ! -f $taskDir/filelist_$ijob.txt ];then
      cp /dev/null $taskDir/filelist_$ijob.txt
    fi
  
    echo $autofile >> $taskDir/filelist_$ijob.txt
  done
  
  #cd $autoCurrentDir
 
  if [ $MultipleJobs -eq 0 ] ;then
    execMult='echo '
    MultipleJobs=1
  fi
  execMultBase=$execMult
  for iExec in `seq 1 $ijob`;do
    execMult="$execMult ; $execMultBase"
  done
  
  
}

make_hadd_job(){

  if [ "$taskname" == "NULL" ] ; then
    echo '[btask] ERROR : Please specify a task name using -task <taskname>'
    exit
  else
    job=`( cat $ongodb | grep "$taskname" | sed "s: :;:g")`
  fi

  if [ -z "$job" ] ; then
    echo "[btask] ERROR : Task $taskname not found."
    exit
  fi


  declare -a arr2
  arr2=$(echo $job | tr ";" "\n")
  taskName=`(echo ${arr2[0]} | awk '{print $1}')`

  # Check if job is done
  taskname=$taskName  
  echo " "
  echo "[btask] INFO: Checking task: "$taskname    
  get_status
  if [ $ALLJOBDONE -eq 0 ] ; then
    echo "[btask] ERROR: Not all jobs are done for task: "$taskname
    exit
  fi
  
  # Retrieve task parameters 
  
  get_taskParam
  cfg=$taskDir/$taskNAME.cfg 
  parse_config
  taskName=`(echo ${arr2[0]} | awk '{print $1}')`
  
  echo '[btask] INFO: Retrieving task: '$taskName 
  taskId=`echo $taskName"_hadd"|sed "s:#:_:"`
  
  declare -a sandboxes
  declare -a outputfiles
  
  tarFile="OutputSandbox.tgz"
  
  
  # Loop over SandBoxes and untar
  missingoutputs=0
  for name in ${arr2[@]} ; do
    if [ ! "$name" == "$taskName" ] ; then

      cd $taskSdb"/Sandbox_$name/"
      
      #checking if $tarFile is present
      if [ ! -f $tarFile ];then
        echo '[btask] WARNING : No output files were present for job '$name
	missingoutputs=1
	continue
      fi

      #add to list of sandboxes
      sandboxes=`echo $sandboxes $taskSdb"/Sandbox_$name/"`
      #echo $sandboxes
      
      # Unpack tar file
      tar xzf $tarFile
    fi
  done
  
  if [ $missingoutputs -gt 0 ];then
    echo '[btask] INFO : You should try to resubmit the task with btask -resubmit -task '$taskName
    read -p "        ==> Do you want to continue with the hadd job ? [y/n] [default=y]  " a 
    case $a in
      n )
        exit
      ;;
    esac
        
  fi
  
  #making list of output files
  outputfiles=''
  fileList=`(tar vxzf $taskSdb/Sandbox_$name/$tarFile)`
  for file in $fileList ; do
    if [ `file $file|grep 'ROOT' -c` -eq 1 ];then
      outputfiles=`echo $outputfiles $file`
    fi
  done
  
  if [ ${#outputfiles[@]} -eq 0 ];then
    echo "[btask] Warning : no root ouput files were created by the job. Nothing to hadd ..."
    exit 
  fi
  
  echo "[btask] INFO : Will run ${#outputfiles[@]} hadd subjobs on the ${#outputfiles[@]} following output files :"
  echo "               ${outputfiles[@]}"
  
  
  #making path to execute
  execmult='ff'
  for iOutputFile in ${outputfiles[@]};do
    #hadd_command='hadd -f '${iOutputFile%.root}'_'$taskId'.root'
    hadd_command='hadd -f '$iOutputFile
  
    for iSandBox in ${sandboxes[@]};do
      if [ ! -f $iSandBox/$iOutputFile ];then
        echo '[btask] WARNING : subjob managed to retrieve output, but problem arrised when untaring '$iOutputFile' from '$iSandBox
	echo '                  Will not run hadd on this subjob'
        read -p "        ==> Do you want to continue with the hadd job ? [y/n] [default=y]  " a 
        case $a in
          n )
            exit
          ;;
        esac
	continue
      fi
      
      
      hadd_command=`echo $hadd_command $iSandBox/$iOutputFile`   
       
    done
    
    execmult=`echo $execmult" ; "$hadd_command`
  done


  #making temp conf file
  cp /dev/null conf_$taskId.txt
  echo 'taskName = '`echo $taskName|sed "s:#.*::"`	>> conf_$taskId.txt
  echo 'inDir    = '`pwd`				>> conf_$taskId.txt
  echo 'inList   = 'conf_$taskId.txt			>> conf_$taskId.txt
  echo 'outDir   = '$outDir				>> conf_$taskId.txt
  echo 'outList  = "*.root"'				>> conf_$taskId.txt
  echo 'execBase = '$sourceroot_command			>> conf_$taskId.txt
  echo 'execMult = '`echo $execmult|sed "s#ff ;##"`	>> conf_$taskId.txt
  
  echo -e "\n[btask] INFO : Launching hadd job $taskId"
  echo -e "==========================================================================================\n"
  #echo ""
  
  btask -submit conf_$taskId.txt -tag "hadd_"`echo $taskName|sed "s:.*#::"`
  
}




submit_jobs(){

  #saving existing filelist, to restore after jobs are launched
  if [ -f $inDir/filelist.txt ] && [ $autoNJobs -ne 0 ];then
    #echo "Moving existing $inDir/filelist.txt in /tmp/filelist_$taskID"
    mv $inDir/filelist.txt /tmp/filelist_$taskID
  fi

  SUBMIT="subjob --sdbdir $taskSdb --inDir $inDir --outList $outList" 
  iJob=0

  if [ $MultipleJobs -eq 0 ] ; then 
    iJob=`expr $iJob + 1`
    echo $execBase
    #JOB=`echo $execBase' --jobid '$taskID'_'$iJob '--inList '$inList`
    JOB=`echo '--jobid '$taskID'_'$iJob' --exec '$execBase '--inList' $inList`
    JobID=`($SUBMIT $JOB | grep JobID | awk -F":" '{print $2}' | sed "s: ::g")`
    vJobID[$[${#vJobID[@]}+1]]=$JobID

  else

    SaveIFS=$IFS
    IFS=';' read -ra JOBS <<< "$execMult"
    for j in "${JOBS[@]}"; do
      if [ $autoNJobs -gt 0 ];then
        cp $taskDir/filelist_$iJob.txt $inDir/filelist.txt
	inList=`echo "$inList filelist.txt"`
      fi
      iJob=`expr $iJob + 1`
      JOB=`echo '--jobid '$taskID'_'$iJob' --exec '$execBase ' ; ' $j '--inList' $inList`
      JobID=`($SUBMIT $JOB | grep JobID | awk -F":" '{print $2}' | sed "s: ::g")`
      vJobID[$[${#vJobID[@]}+1]]=$JobID
    done
    IFS=$SaveIFS

  fi
  
  #restoring previously saved filelist.txt
  if [ -f /tmp/filelist_$taskID ];then
    mv /tmp/filelist_$taskID $inDir/filelist.txt
  fi
}

register_task(){
  cp /dev/null $taskDir/$taskName.cfg
  print_config >> $taskDir/$taskName.cfg
  echo $taskName'#'$taskID' '${vJobID[@]} >> $ongodb
  echo "[btask] INFO: The following task has been started: "$taskName"#"$taskID
  echo "[btask] INFO: composed of subtask : "${vJobID[@]}
}

remove_task(){
  echo "[btask] INFO: Removing task: "$taskName
  cat $ongodb | grep    "$taskName" >> $donedb 
  tmpFile=`(mktemp)`
  cat $ongodb | grep -v "$taskName" >> $tmpFile
   mv  $tmpFile $ongodb
#  echo "---- DONE DB -----"
#  cat $donedb
#  echo "---- ONGO DB -----"
#  cat $ongodb 
}

print_status(){
  statusVerbose=1
  echo "#CPU      Free    Total Jobs      Running Waiting ComputingElement    "
  echo "----------------------------------------------------------------------"
  lcg-infosites --vo cms ce | grep "cream01.iihe.ac.be"
  echo "######################################################################"
  get_status
  statusVerbose=0
}

get_taskParam(){
   taskNAME=`(echo $taskName | awk -F"#" '{print $1}')`
   taskID=`(echo $taskName | awk -F"#" '{print $2}')`
   taskDir=$workdir/$taskNAME'_'$taskID
   taskSdb=$sdbdir/$taskNAME'_'$taskID
}

get_status(){

  if [ "$taskname" == "NULL" ] ; then
    joblist1=`( cat $ongodb | sed "s: :;:g")` 
  else
    joblist1=`( cat $ongodb | grep "$taskname"  | sed "s: :;:g")`  
  fi

  if [ ! -z "$joblist1" ] ; then
    if [ $statusVerbose -eq 1 ] ; then
      echo "Job ID               Username Queue    Jobname          SessID NDS   TSK Memory Time  S Time "
      echo "-------------------- -------- -------- ---------------- ------ ----- --- ------ ----- - -----"
    fi
  else
    echo "[btask] INFO: get_status No active task"
  fi

  ALLJOBDONE=1

  for job in $joblist1 ; do
    declare -a arr
    arr=$(echo $job | tr ";" "\n")
    taskName=`(echo ${arr[0]} | awk '{print $1}')`
    if [ $statusVerbose -eq 1 ] ; then
      echo "------------------------- Task : $taskName  ----------------------------"
    fi
    for name in ${arr[@]} ; do
      if [ ! "$name" == "$taskName" ] ; then
        get_taskParam
        testFile=$taskSdb"/Sandbox_$name/OutputSandbox.tgz"
        res=`(qstat -u $USER localgrid@cream01 | grep $name)` 
        if [ ! -z "$res" ]; then
          if [ $statusVerbose -eq 1 ] ; then 
            echo "$res"
          fi
          ALLJOBDONE=0
          
        else
          res=`(ls $testFile 2>&1)`
          if [ $statusVerbose -eq 1 ] ; then
            echo $name" DONE -> File: "$res
          fi
        fi  
      fi
    done
  done

}

kill_jobs(){

if [ "$taskname" == "NULL" ] ; then
  joblist3=`( cat $ongodb | sed "s: :;:g")` 
else
  joblist3=`( cat $ongodb | grep "$taskname"  | sed "s: :;:g")`  
fi

  if [ -z "$joblist3" ] ; then
    echo "[btask] INFO: kill_jobs:  No active task"
  else

  for job in $joblist3 ; do
    declare -a arr
    arr=$(echo $job | tr ";" "\n")
    taskName=`(echo ${arr[0]} | awk '{print $1}')`
    taskname=$taskName
    get_taskParam 
    echo "[btask] INFO: Killing Task: "$taskname
    for name in ${arr[@]} ; do
      if [ ! "$name" == "$taskName" ] ; then
        echo "[btask] INFO: Killing SubTask: "$name
        # Kill job (if still running)
        res=`(qstat -u $USER localgrid@cream01 | grep $name)` 
        if [ ! -z "$res" ]; then
          id=`(echo $res | awk '{print $1}' | awk -F'.' '{print $1}')`
          qdel $id.cream01 
        fi
        # Remove SubTask SandBox
        rm -rf $taskSdb/Sandbox_$name
      fi
    done
    # Remove Task SandBox
    rm -rf $taskSdb
    # Remove Task form ongoing DB 
    remove_task


  done
fi

} 


get_out(){

  if [ "$taskname" == "NULL" ] ; then
    joblist2=`( cat $ongodb | sed "s: :;:g")`
  else
    joblist2=`( cat $ongodb | grep "$taskname" | sed "s: :;:g")`
  fi

  if [ -z "$joblist2" ] ; then
    echo "[btask] INFO: No active task"
  fi


  for job in $joblist2 ; do
    declare -a arr2
    arr2=$(echo $job | tr ";" "\n")
    taskName=`(echo ${arr2[0]} | awk '{print $1}')`

    # Check if job is done

     
    taskname=$taskName  
    echo " "
    echo "[btask] INFO: Checking task: "$taskname    
    get_status
    if [ $ALLJOBDONE -eq 0 ] ; then
      echo "[btask] ERROR: Not all jobs are done for task: "$taskname
      #print_status
    else

      # Retrieve task parameters 
  
      get_taskParam
      cfg=$taskDir/$taskNAME.cfg 
      parse_config
      taskName=`(echo ${arr2[0]} | awk '{print $1}')`
  
      echo '[btask] INFO: Retrieving task: '$taskName 
      echo '	    ==> log files are in '$taskDir
  
      # Go to outDir 
  
      cd $outDir
      iJob=0
  
      tmpdir=$taskNAME'_'$taskID
      mkdir $tmpdir
      cd $tmpdir
  
      clean=1
      read -p "[btask] INFO: Do you want to clean this task ? [y/n] [default=y]  " a 
      case $a in
        n )
          clean=0
        ;;
      esac
  
      # Loop over SandBoxes 
  
      for name in ${arr2[@]} ; do
        if [ ! "$name" == "$taskName" ] ; then
          iJob=`expr $iJob + 1`
          echo "[btask] INFO: Retrieving task: "$taskName " job: "$iJob 
  
          if [ "$tag" == "NULL" ] ; then
            tagID=$taskID
          else
            tagID=$tag
          fi


	  
          tarFile=$taskSdb"/Sandbox_$name/OutputSandbox.tgz"
	  
	  #checking if $tarFile is present
          if [ ! -f $tarFile ];then
            echo '[btask] WARNING : No output files were present for job '$name
	    continue
          else
	    
            # Unpack tar file
	    echo '	    ==> output files :'
            fileList=`(tar tzf $tarFile)`
            for file in $fileList ; do
              test=`echo $file | (grep "\.")`
              if [ ! -z $test ] ; then
                first=`(echo  $file | awk '{split($0,a,"."); n=0 ; for (i in a) n++ ; nm1=n-1; for (i=1; i<nm1; i++) printf a[i]"." ; print a[nm1]"_" }')`
                middle=$taskNAME'_'$tagID'_'$iJob'.'
                last=`(echo  $file | awk '{split($0,a,"."); n=0 ; for (i in a) n++ ; print a[n]}')`
                outfile=$first$middle$last
              else
                outfile=$file"_"$taskNAME'_'$tagID'_'$iJob
              fi           
              tar xzf $tarFile $file 
              mv $file ../$outfile
	      echo '                 '"$outDir/$outfile"
            done
          fi
	  
	  
	  
          # Copy logfiles
  
          errFileIn=$taskSdb"/Sandbox_$name/stderr"
          outFileIn=$taskSdb"/Sandbox_$name/stdout"
  
          errFileOut=$taskDir"/stderr_$iJob"
          outFileOut=$taskDir"/stdout_$iJob"
  
          cp $errFileIn $errFileOut
          cp $outFileIn $outFileOut
          
  
          # Remove SubTask SandBox
	  if [ $clean -eq 1 ];then
            rm -rf $taskSdb/Sandbox_$name
	  fi
	  
        fi
      done
      cd ..
      rm -rf $tmpdir 
      
      
      if [ $clean -eq 1 ];then
        # Remove Task SandBox
        rm -rf $taskSdb
 
        # Remove Task form ongoing DB 
        remove_task
      fi
  
    fi
  done
  
}

resubmit(){


  if [ "$taskname" == "NULL" ] ; then
    echo '[btask] ERROR : Please specify a task name using -task <taskname>'
    exit
  else
    job=`( cat $ongodb | grep "$taskname" | sed "s: :;:g")`
  fi

  if [ -z "$job" ] ; then
    echo "[btask] ERROR : Task $taskname not found."
    exit
  fi


  declare -a arr2
  arr2=$(echo $job | tr ";" "\n")
  taskName=`(echo ${arr2[0]} | awk '{print $1}')`

  # Check if job is done
  taskname=$taskName  
  echo " "
  echo "[btask] INFO: Checking task: "$taskname    
  get_status
  if [ $ALLJOBDONE -eq 0 ] ; then
    echo "[btask] ERROR: Not all jobs are done for task: "$taskname
    exit
  fi
  
  # Retrieve task parameters 
  
  get_taskParam
  cfg=$taskDir/$taskNAME.cfg 
  parse_config
  taskName=`(echo ${arr2[0]} | awk '{print $1}')`
  
  #echo '[btask] INFO: Retrieving task: '$taskName 
  
  tarFile="OutputSandbox.tgz"
  
  # Loop over SandBoxes and untar
  for name in ${arr2[@]} ; do
    if [ ! "$name" == "$taskName" ] ; then

      cd $taskSdb"/Sandbox_$name/"
      
      #checking if $tarFile is present
      if [ ! -f $tarFile ];then
        echo '[btask] WARNING : No output files were present for job '$name
        echo '        ==> resubmitting the job '
	qsub -N $name -q localgrid@cream01 -o `pwd`/stdout_retry -e `pwd`/stderr_retry qsub.sh > /dev/null
      fi

    fi
  done

}


# ----------------------------  Parsing  Arguments  ----------------------------

submit=0
status=0
getout=0
jkill=0
resubmit=0
addroot=0
tag="NULL"
taskname="NULL"

for arg in $* ; do

  case $arg in
    -submit)    submit=1   ; option=$2   ; shift ; shift ;;
    -status)    status=1                         ; shift ;;
    -get)       getout=1                         ; shift ;;
    -kill)      jkill=1                          ; shift ;;
    -resubmit)  resubmit=1 			 ; shift ;;
    -hadd)      addroot=1  			 ; shift ;;
    -task)                   taskname=$2 ; shift ; shift ;;
    -tag)                    tag=$2      ; shift ; shift ;;
    -help)      Usage ;;
    *) ;;
  esac

done

# Check arguments (Only one action per command)

test=0
test=`expr $test + $submit`
test=`expr $test + $status`
test=`expr $test + $getout`
test=`expr $test + $jkill`
test=`expr $test + $resubmit`
test=`expr $test + $addroot`

if [ $test -eq 0 ] ; then
  echo "Error: No valid arguments !"
  Usage
fi
if [ $test -gt 1 ] ; then
  echo "Error: Can not do submit, status, get, resubmit, hadd at the same time !"
  Usage
fi

# ------------------------  SUBMIT  JOB(S) --------------------------------------

if [ $submit -eq 1 ] ; then

  cfg=$option 
  parse_config
  echo "[btask] INFO: The following config will be used to start a task:"
  print_config
  check_config
  mkdir_task
  make_autofilelist
  submit_jobs
  register_task

fi # end [ $submit -eq 1 ] 

# ------------------------  KILL JOB(S) -----------------------------------------

if [ $jkill  -eq 1 ] ; then

  kill_jobs

fi # end [ $jkill  -eq 1 ]

# ------------------------  RESUBMIT  JOB(S) ------------------------------------

if [ $resubmit -eq 1 ] ; then

  resubmit

fi # end [ $resubmit -eq 1 ] 


# ------------------------  JOB(S) STATUS --------------------------------------

if [ $status -eq 1 ] ; then

  print_status

fi # end [ $status -eq 1 ]

# ------------------------  JOB(S) OUTPUT  RETRIEVAL  --------------------------

if [ $getout -eq 1 ] ; then

  get_out

fi # end [ $getout -eq 1 ] 

# ------------------------  JOB(S) OUTPUT  MERGE  ------------------------------

if [ $addroot -eq 1 ] ; then

  make_hadd_job

fi # end [ $addroot -eq 1 ]


 
