#!/bin/bash
#
########################################################################
#
# author:  Xavier Janssen                                08/03/2011
# purpose: Create and submit IIHE local job 
#          Full options !
#
########################################################################


### Usage:

Manual=$( cat <<SETVAR
 
 options: btask -submit <config>  : Submit job based on <config> file
          btask -status           : Get status of all jobs
          btask -get              : Retrieve output of all terminated jobs
          btask -kill             : Kill all jobs
                -tag  <tag>       : Replace the random job tag by <tag>
                                    Apply it together with -submit or -get
                -task <taskname>  : Adding to -status, -get or -hadd 
                                    restrict action to a single <taskname>
          btask -help             : Print this help message 

SETVAR
)

# btask -resubmit all     : Resubmit all jobs
# btask -resubmit <jobid> : Resubmit jobs <jobid> (comma separated list) 
# btask -hadd <taskname>  : Add all root files of a finished <taskname>
#                     -get will retrieve the added root file

# ---------------------------- Variables ---------------------------------------


BLUE='\033[1;34m'
CYAN='\033[1;36m'
RED='\033[1;31m'
GREEN='\033[1;32m'
YEL='\033[1;33m'
DEF='\033[0;m'


declare -a vJobID
statusVerbose=0
sourceroot_command='source /localgrid/xjanssen/root_5.26.00e_iihe_default_dcap/root/bin/thisroot.sh'
pnfsdir="/pnfs/iihe/cms/store/user/$USER/"


btask_config=`dirname $0`'/../config/btask.conf'
workdir=$HOME'/'`( cat $btask_config | grep workdir | awk '{print $2}' )`
if [ ! -d $workdir ] ; then
  mkdir -p $workdir 
fi
dbdir=$HOME'/'`( cat $btask_config | grep jobdbdir | awk '{print $2}' )`
if [ ! -d $dbdir ] ; then
  mkdir -p $dbdir
fi
ongodb=$dbdir'/'`( cat $btask_config | grep ongoing_db | awk '{print $2}' )`
if [ ! -f $ongodb ];then
  touch $ongodb
  echo -e "${CYAN}[btask] WARNING :${DEF} No ongoingjob.db file -> void file created !!!!!"
fi
donedb=$dbdir'/'`( cat $btask_config | grep donejob_db | awk '{print $2}' )`
if [ ! -f $donedb ];then
  echo -e "${CYAN}[btask] WARNING :${DEF} No finishedjob.db file -> void file created !!!!!"
  touch $donedb
fi

sdbdir=$(eval echo $( cat $btask_config | grep sandboxdir | awk '{print $2}' ))

hadd_code=$(eval echo $( cat $btask_config | grep hadd_code | awk '{print $2}' ))
hadd_dir="`cat $btask_config | grep hadd_dir | sed 's:hadd_dir::'`"
hadd_inc="`cat $btask_config | grep hadd_inc | sed 's:hadd_inc::'`"
hadd_src="`cat $btask_config | grep hadd_src | sed 's:hadd_src::'`"


# ---------------------------- Functions ---------------------------------------

Usage()
{
  echo "$Manual" ; exit ;
}

UsageCfg()
{
  echo "Missing some inputs in cfg file ! "; print_config ; exit ;
}


print_config()
{
  echo "taskName   = "$taskName
  echo "inDir      = "$inDir   
  echo "inList     = "$inList  
  echo "outDir     = "$outDir   
  echo "outList    = "$outList 
  echo "execBase   = "$execBase
  echo "execMult   = "$execMult
  if [ $autoON != 0 ];then
    echo "autoFiles           = $autoFiles"
    echo "autoNJobs           = $autoNJobs"
    echo "autoNfiles_per_jobs = $autoNfiles_per_jobs"
  fi
}

parse_config()
{
  #echo "--> Parsing cfg file: "$cfg
  MultipleJobs=1
  grep taskName  $cfg -q && taskName=`( cat $cfg | grep taskName  | awk -F"=" '{print $2}' | sed "s: ::g")` || UsageCfg
  grep inDir     $cfg -q && inDir=`(    cat $cfg | grep inDir     | awk -F"=" '{print $2}'               )` || UsageCfg
  grep inList    $cfg -q && inList=`(   cat $cfg | grep inList    | awk -F"=" '{print $2}'               )` || UsageCfg
  grep outDir    $cfg -q && outDir=`(   cat $cfg | grep outDir    | awk -F"=" '{print $2}'               )` || UsageCfg
  grep outList   $cfg -q && outList=`(  cat $cfg | grep outList   | awk -F"=" '{print $2}'               )` || UsageCfg
  grep execBase  $cfg -q && execBase=`( cat $cfg | grep execBase  | awk -F"=" '{print $2}'               )` || UsageCfg
  grep execMult  $cfg -q && execMult=`(cat $cfg  | grep execMult  | awk -F"=" '{print $2}'               )` || MultipleJobs=0
  
  #auto Variables
  grep autoFiles $cfg -q && autoFiles=`(cat $cfg | grep autoFiles | awk -F"=" '{print $2}'               )` || autoFiles=0
  grep autoNJobs $cfg -q && autoNJobs=`(cat $cfg | grep autoNJobs | awk -F"=" '{print $2}'               )` || autoNJobs=0
  grep autoNfiles_per_jobs $cfg -q && autoNfiles_per_jobs=`(cat $cfg | grep autoNfiles_per_jobs | awk -F"=" '{print $2}' )` || autoNfiles_per_jobs=0
  #grep autoFileManagerArgs $cfg -q && autoFileManagerArgs=`(cat $cfg | grep autoFileManagerArgs | awk -F"=" '{print $2}'               )` || autoNJobs=0
  #print_config
  
  
  return 1
}

check_config()
{
  autoON=0
  if [ "$autoFiles" != "0" ];then
    autoON=1
  fi
  
  if [ $autoNJobs -ne 0 ] && [ $autoNfiles_per_jobs -ne 0 ];then
    echo -e "${RED}[btask] ERROR :${DEF} You need to specify only one of autoNJobs & autoNfiles_per_jobs."
    exit
  fi
  
  if [ $autoNJobs -ne 0 ] || [ $autoNfiles_per_jobs -ne 0 ];then
    if [ $autoON -eq 0 ];then
      echo -e "${RED}[btask] ERROR :${DEF} You need to specify autoFiles if you want to parallelize your jobs."
      exit
    fi
  fi

  #Checking if more than 1 job in execMult when autoON is on
  if [ $MultipleJobs -gt 0 ] && [ $autoON -gt 0 ];then
    if [ `echo $execMult|grep ';' -c` -gt 0 ];then
      echo -e "${RED}[btask] ERROR :${DEF} autoFile is on : you must have at most 1 job in execMult ( or you left a \";\"  at the end ? ) . Exiting ..."
      exit ;
    fi  
  fi
}

mkdir_task(){
  if [ "$tag" == "NULL" ] ; then 
    taskID=`(mktemp -p $workdir -t .XXX | awk -F'.' '{print $2}')`
  else
    taskID=$tag
  fi 
  taskDir=$workdir/$taskName'_'$taskID
  taskSdb=$sdbdir/$taskName'_'$taskID
  mkdir -p $taskDir
  mkdir -p $taskSdb
}

get_specific_task(){
  if [ "$taskname" == "NULL" ] ; then
    echo -e "${RED}[btask] ERROR :${DEF} Please specify a task name using -task <taskname>"
    exit
  else
    job=$( cat $ongodb |sed 's: :#:g'| grep "$taskname#"|sed 's:#: :g')  
  fi
  
  if [ -z "$job" ] ; then
    echo -e "${RED}[btask] ERROR :${DEF} Task $taskname not found."
    exit
  fi
  
  # Check if job is done
  get_para_from_db
  is_task_finished
  if [ `get_task_status` -eq 0 ] ; then
    exit
  fi
}

get_tasks(){
  if [ "$taskname" == "NULL" ] ; then
    joblist=`( cat $ongodb | sed "s: :;:g")` 
  else
    joblist=$( cat $ongodb | sed "s: :;:g "| grep "`echo $taskname|sed 's:#:;:'`")  
  fi
  
  if [ -z "$joblist" ] ; then
    echo -e "${GREEN}[btask] INFO :${DEF} No active task"
    exit
  fi
}

print_status(){
  echo -e "${BLUE}#CPU      Free    Total Jobs      Running Waiting ComputingElement${DEF}    "
  echo -e "----------------------------------------------------------------------"
  lcg-infosites --vo cms ce | grep "cream01.iihe.ac.be"
  echo -e "######################################################################"
  
  get_tasks
    
  echo -e "${BLUE}Job ID  	     Username Queue    Jobname  	SessID NDS   TSK Memory Time  S Time${DEF} "
  echo -e "-------------------- -------- -------- ---------------- ------ ----- --- ------ ----- - -----"
  
  for job in $joblist ; do
    job=`echo $job | sed "s:;: :g"`
    get_para_from_db
    print_task_status
  done
}

print_task_status(){
  echo -e "------------------------- Task : ${BLUE}$taskFullName${DEF}  ----------------------------"
  for i in `seq 0 $( expr $nJobs - 1 )` ; do
    testFile="${sandboxes[$i]}OutputSandbox.tgz"
    res=`(qstat -u $USER localgrid@cream01 | grep  ' '"${taskids[$i]}"' ')` 
    if [ ! -z "$res" ]; then
      if [ `echo $res|grep -e " Q " -c` -eq 1 ];then
        echo -e "${RED}$res${DEF}"
      else
        echo -e "${YEL}$res${DEF}"
      fi
    else
      res=`(ls $testFile 2>&1)`
      if [ $pnfs -eq 0 ];then
        echo -e "${GREEN}${taskids[$i]} DONE${DEF} -> File: "$res
      else
        echo -e "${GREEN}${taskids[$i]} DONE${DEF} -> File on pnfs: "`ls $pnfsdir${sandboxes[$i]} 2>&1`
      fi
    fi
  done
}

get_para_from_db(){
  taskName=`echo $job|awk '{print $1}'`
  taskId=`echo $job|awk '{print $2}'`
  taskFullName=`echo $taskName"#"$taskId`
  nJobs=`echo $job|awk '{print $3}'`
  pnfs=`echo $job|awk '{print $4}'`
  
  taskDir=$workdir/$taskName'_'$taskId
  taskSdb=$sdbdir/$taskName'_'$taskId
  
  cfg=$taskDir/$taskName.cfg
  parse_config
  
  #making list of sandboxes & taskids
  #declare -a sandboxes
  #declare -a taskids
  sandboxes=( '' )
  taskids=( '' )
  for i in `seq 1 $nJobs`;do
    sandboxes=( `echo "${sandboxes[*]}" "$taskSdb/Sandbox_$taskId"_"$i/"` )
    taskids=( `echo "${taskids[@]}" "$taskId""_""$i"` )
  done
}


add_task_to_db(){
  cp /dev/null $taskDir/$taskName.cfg
  print_config >> $taskDir/$taskName.cfg
  echo $taskName' '$taskID' '${#vJobID[@]}' '$pnfs >> $ongodb
  echo -e "${GREEN}[btask] INFO :${DEF} The following task has been started: ${YEL}$taskName#$taskID${DEF}"
  echo -e "${GREEN}[btask] INFO :${DEF} composed of subtask : ${YEL}${vJobID[@]}${DEF}"
}


remove_task_from_db(){
  echo -e "${GREEN}[btask] INFO :${DEF} Removing task: "$taskFullName
  cat $ongodb | grep    "$taskName $taskId" >> $donedb 
  tmpFile=`(mktemp)`
  cat $ongodb | grep -v "$taskName $taskId" >> $tmpFile
  mv  $tmpFile $ongodb
}

get_task_status(){
  ALLJOBDONE=1
  for i in `seq 0 $( expr $nJobs - 1 )` ; do
    res=`(qstat -u $USER localgrid@cream01 | grep  ' '"${taskids[$i]}"' ')` 
    if [ ! -z "$res" ]; then
      ALLJOBDONE=0
    fi
  done
  echo $ALLJOBDONE
}

is_task_finished(){
  echo -e "\n${GREEN}[btask] INFO :${DEF} Checking task: "$taskFullName
  if [ `get_task_status`  -eq 0 ] ; then
    echo -e "${RED}[btask] ERROR :${DEF} Not all jobs are done for task: "$taskFullName
  fi
}

is_in_db(){
  echo `cat $ongodb | grep "$1 $2" -c`
}

make_autofilelist(){

  if [ $autoON -eq 0 ];then
    return 
  fi

  
  if [ `echo $autoFiles|grep ".txt" -c` -eq 1 ];then
    autodir=''
    autolist=`cat $inDir'/'$(echo $autoFiles|sed "s# ##")`
    echo -e "${GREEN}[btask] INFO :${DEF} Input is a txt file"
  else
    
    if [ -d `echo $autoFiles|awk '{print $1}'` ];then
      autodir=$autoFiles
      autolist=`ls -d $autoFiles/*`
      echo -e "${GREEN}[btask] INFO :${DEF} Input is a directory"
    else
      autodir=''
      autolist=`ls -d $autoFiles`
      echo -e "${GREEN}[btask] INFO :${DEF} Input is a list of files"
    fi
  fi
  rm -fr $taskDir/filelist_[0-9].txt

  nfiles=`echo $autolist|sed "s# #\n#g"|wc -l`
  #echo '[btask] INFO : Number of files to divide :' $nfiles
  #echo '[btask] INFO : Number of Jobs to do :' $autoNJobs
  files_per_jobs=`expr $nfiles / $autoNJobs`
  #echo '[btask] INFO : Files per Jobs : ' $files_per_jobs
  if [ $autoNJobs -gt $nfiles ];then
    autoNJobs=$nfiles
  fi
  
  
  echo -e "${GREEN}[btask] INFO :${DEF} Will create automatically $autoNJobs(+1?) jobs with $files_per_jobs files per jobs"
  echo -e '               Your code needs to take filelist.txt as input , which is automatically created in "inDir" and added to "inList"'
  echo -e '               If filelist.txt already exists in "inDir"  , it will first be moved, and then restored at the end of the job'
  
  

  nfile_injob=0
  ijob=0
  for autofile in $autolist;do
    if [ `echo $autofile|grep "pnfs" -c` -gt 0 ];then
      if [ `echo $autofile|grep -v 'dcap:///' -c` -gt 0 ];then
        autofile="dcap://$autofile"
      fi
    fi
  
    let nfile_injob=$nfile_injob+1
  
    if [ $nfile_injob -gt $files_per_jobs ];then
      nfile_injob=1
      let ijob=$ijob+1
    fi
  
    #creating filelist i
    if [ ! -f $taskDir/filelist_$ijob.txt ];then
      cp /dev/null $taskDir/filelist_$ijob.txt
    fi
  
    echo $autofile >> $taskDir/filelist_$ijob.txt
  done
  
  #cd $autoCurrentDir
 
  if [ $MultipleJobs -eq 0 ] ;then
    execMult='echo '
    MultipleJobs=1
  fi
  execMultBase=$execMult
  for iExec in `seq 1 $ijob`;do
    execMult="$execMult ; $execMultBase"
  done
  
  
}

hadd_all(){
  get_tasks
  for job in $joblist ; do
    job=`echo $job | sed "s:;: :g"`
    get_para_from_db
    
    #skip hadd jobs
    if [ `echo $taskId|grep hadd -c` -eq 1 ];then
      continue
    fi
    
    echo -e "\n------------------------- Task : ${BLUE}$taskFullName${DEF}  ----------------------------"
    taskname=$taskFullName
    
    make_hadd_job
  done
}





make_hadd_job(){

  get_specific_task
  
  if [ `is_in_db $taskName hadd_$taskId` -eq 1 ];then
    echo -e "${GREEN}[btask] INFO :${DEF} hadd already done on this task. Please kill the hadd job before re-running it."
    return
  fi 
    
  outputfiles=( '' )
  tarFile="OutputSandbox.tgz"  
  
  # Loop over SandBoxes and untar
  missingoutputs=0
  for i in `seq 0 $( expr $nJobs - 1 )` ; do

    cd ${sandboxes[$i]}
    
    #checking if $tarFile is present
    if [[ ! -f $tarFile && $pnfs -eq 0 ]] || [[ $pnfs -gt 0  && `ls $pnfsdir${sandboxes[$i]}|wc -l` -eq 0 ]] ;then
      echo -e "${CYAN}[btask] WARNING :${DEF} No output files were present for job "${taskids[$i]}
      missingoutputs=1
      continue
    fi
    
    # Unpack tar file
    if [ $pnfs -eq 0 ] ;then
      tar xzf $tarFile
    fi
    
  done
  
  if [ $missingoutputs -gt 0 ];then
    echo -e "${GREEN}[btask] INFO :${DEF} You should try to resubmit the task with btask -resubmit -task "$taskFullName
    read -p "        ==> Do you want to continue with the hadd job ? [y/n] [default=y]  " a 
    case $a in n ) exit ;; esac
  fi
  
  #making list of output files
  outputfiles=''
  if [ $pnfs -eq 0 ] ;then
    fileList=`(tar tzf ${sandboxes[$i]}/$tarFile)`
  else
    fileList=`ls $pnfsdir${sandboxes[$i]}`
  fi
  
  for file in $fileList ; do
    #if [ `file $file|grep 'ROOT' -c` -eq 1 ];then  #can't use it on pnfs ...
    if [ `echo $file|grep '.root' -c` -eq 1 ];then
      outputfiles=( `echo "${outputfiles[@]}" "$file"` )
    fi
  done
  
  if [ ${#outputfiles[@]} -eq 0 ];then
    echo -e "${CYAN}[btask] WARNING :${DEF} no root ouput files were created by the job. Nothing to hadd ..."
    exit 
  fi
  
  echo -e "${GREEN}[btask] INFO :${DEF} Will run ${#outputfiles[@]} hadd subjobs on the ${#outputfiles[@]} following output files :"
  echo -e "               ${outputfiles[@]}"
  
  
  #making path to execute
  execmult='ff'
  haddOutFiles=''
  ihaddOutFiles=0
  makeDIR=''
  imakeDIR=0
  HADD="hadd"
  if [ $hadd_tweak -eq 1 ];then
    HADD="./hadd_tweak"
  fi
  
  for iOutputFile in ${outputfiles[@]};do
    #hadd_command='hadd -f '${iOutputFile%.root}'_'$taskId'.root'
    hadd_command="$HADD -f "$iOutputFile
    
    #################### FIXME
    #  Xavier Stuff ==> Surely not needed when -pnfs
    if [ $ihaddOutFiles == 0 ] ; then
      haddOutFiles=$iOutputFile
      ihaddOutFiles=1
    else
      haddOutFiles=$haddOutFiles' , '$iOutputFile
    fi  
    if [ ! -z "$(echo $iOutputFile | sed -n 's:\([/]\):\1:p')" ]; then
      DIR=`(echo $iOutputFile | awk '{split($0,a,"/") ; n=0 ; for (i in a) n++ ; for (i=1; i<n; i++) printf a[i]"/" }')`
      makeDIR=$makeDIR' ; mkdir -p '$DIR
    fi
    ####################
    
    for iSandBox in ${sandboxes[@]};do
      if [[ ! -f $iSandBox/$iOutputFile && -f $iSandBox/$tarFile && $pnfs -eq 0 ]] || [[ $pnfs -gt 0 && ! -f $pnfsdir$iSandBox/$iOutputFile ]] ;then
        echo -e "${CYAN}[btask] WARNING :${DEF} subjob managed to retrieve output, but problem arrised when untaring "$iOutputFile' from '$iSandBox
	echo -e '                  Will not run hadd on this subjob'
        read -p "        ==> Do you want to continue with the hadd job ? [y/n] [default=y]  " a 
        case $a in n ) exit ;; esac
	continue
      fi
      
      if [ $pnfs -eq 0 ] ;then
        hadd_command=`echo $hadd_command $iSandBox/$iOutputFile`   
      else
        hadd_command=`echo $hadd_command dcap://$pnfsdir$iSandBox/$iOutputFile`
      fi
       
    done
    
    execmult=`echo $execmult" ; "$hadd_command`
  done

  inDir_hadd="`pwd`"
  inList_hadd="conf_$taskId.txt"
  execBase_hadd="$sourceroot_command $makeDIR"
  if [ $hadd_tweak -eq 1 ];then
    inDir_hadd="$hadd_dir"
    cd $inDir_hadd
    make_hadd_code $btask_config
    inList_hadd='hadd_tweak.cxx , makeHadd.sh , haddLinkDef.h , '`echo $hadd_src $hadd_inc|sed 's: :,:g'`
    execBase_hadd="$sourceroot_command $makeDIR ;  ./makeHadd.sh -dic -lib -hadd"
    cp $hadd_code $inDir_hadd/.
  fi
  
  
  #making temp conf file
  cp /dev/null conf_$taskId.txt
  echo 'taskName = '`echo $taskName`			>> conf_$taskId.txt
  echo 'inDir    = '$inDir_hadd				>> conf_$taskId.txt
  echo 'inList   = '$inList_hadd			>> conf_$taskId.txt
  echo 'outDir   = '$outDir				>> conf_$taskId.txt
# echo 'outList  = "*.root"'				>> conf_$taskId.txt
  echo 'outList  = '$haddOutFiles                       >> conf_$taskId.txt
  echo 'execBase = '$execBase_hadd			>> conf_$taskId.txt
  echo 'execMult = '`echo $execmult|sed "s#ff ;##"`	>> conf_$taskId.txt
  
  echo -e "\n${GREEN}[btask] INFO :${DEF} Launching hadd job hadd_$taskId"
  echo -e "==========================================================================================\n"
  
  btask -submit conf_$taskId.txt -tag "hadd_$taskId"
  #cat conf_$taskId.txt
}




submit_jobs(){

  #saving existing filelist, to restore after jobs are launched
  if [ -f $inDir/filelist.txt ] && [ $autoNJobs -ne 0 ];then
    #echo "Moving existing $inDir/filelist.txt in /tmp/filelist_$taskID"
    mv $inDir/filelist.txt /tmp/filelist_$taskID
  fi

  SUBMIT="subjob --sdbdir $taskSdb --inDir $inDir --outList $outList" 
  
  if [ $pnfs -gt 0 ];then
    SUBMIT=`echo "$SUBMIT --pnfs"`
  fi
  
  
  iJob=0

  if [ $MultipleJobs -eq 0 ] ; then 
    iJob=`expr $iJob + 1`
    echo $execBase
    #JOB=`echo $execBase' --jobid '$taskID'_'$iJob '--inList '$inList`
    JOB=`echo '--jobid '$taskID'_'$iJob' --exec '$execBase '--inList' $inList`
    JobID=`($SUBMIT $JOB | grep JobID | awk -F":" '{print $2}' | sed "s: ::g")`
    vJobID[$[${#vJobID[@]}+1]]=$JobID

  else

    SaveIFS=$IFS
    IFS=';' read -ra JOBS <<< "$execMult"
    for j in "${JOBS[@]}"; do
      if [ $autoNJobs -gt 0 ];then
        cp $taskDir/filelist_$iJob.txt $inDir/filelist.txt
	inList=`echo "$inList filelist.txt"`
      fi
      iJob=`expr $iJob + 1`
      JOB=`echo '--jobid '$taskID'_'$iJob' --exec '$execBase ' ; ' $j '--inList' $inList`
      JobID=`($SUBMIT $JOB | grep JobID | awk -F":" '{print $2}' | sed "s: ::g")`
      vJobID[$[${#vJobID[@]}+1]]=$JobID
    done
    IFS=$SaveIFS

  fi
  
  #restoring previously saved filelist.txt
  if [ -f /tmp/filelist_$taskID ];then
    mv /tmp/filelist_$taskID $inDir/filelist.txt
  fi
}


kill_jobs(){

  get_tasks

  for job in $joblist ; do
    job=`echo $job | sed "s:;: :g"` 
    get_para_from_db
    
    echo -e "${GREEN}[btask] INFO :${DEF} Killing Task: "$taskFullName
    for i in `seq 0 $( expr $nJobs - 1 )`; do
      echo -e "${GREEN}[btask] INFO :${DEF} Killing SubTask: "${taskids[$i]}
      # Kill job (if still running)
      res=`(qstat -u $USER localgrid@cream01 | grep ${taskids[$i]})` 
      if [ ! -z "$res" ]; then
        id=`(echo $res | awk '{print $1}' | awk -F'.' '{print $1}')`
        qdel $id.cream01 
      fi
      
      # Remove SubTask SandBox
      rm -rf ${sandboxes[$i]}
      
    done
    
    # Remove Task SandBox
    rm -rf $taskSdb
    if [ $pnfs -eq 1 ];then
      rm -fr $pnfsdir$taskSdb
    fi
    
    
    # Remove Task form ongoing DB 
    remove_task_from_db


  done

} 

get_out(){

  get_tasks

  for job in $joblist ; do
    job=`echo $job | sed "s:;: :g"` 
    get_para_from_db
    
    # Check if job is done
    is_task_finished
    if [ `get_task_status` -eq 0 ];then
      continue
    fi
      
    echo -e "${GREEN}[btask] INFO :${DEF} Retrieving task: "$taskFullName 
    echo -e "	  ==> log files are in ${YEL}$taskDir${DEF}"
  
    # Go to outDir 
  
    cd $outDir
  
    tmpdir=$taskName'_'$taskId
    mkdir $tmpdir
    cd $tmpdir
  
    clean=1
    echo -en "${GREEN}[btask] INFO :${DEF}"
    read -p " Do you want to clean this task ? [y/n] [default=y]  " a 
    case $a in n ) clean=0 ;; esac
  
    # Loop over SandBoxes 
    for i in `seq 0 $( expr $nJobs - 1 )` ; do
      echo -e "${GREEN}[btask] INFO :${DEF} Retrieving task $taskFullName   , job ${taskids[$i]}" 
  
      if [ "$tag" == "NULL" ] ; then
        tagID=$taskId
      else
        tagID=$tag
      fi

      tarFile=${sandboxes[$i]}"/OutputSandbox.tgz"
      
      #checking if $tarFile is present
      if [ ! -f $tarFile ] && [ $pnfs -eq 0 ];then
        echo -e "${CYAN}[btask] WARNING :${DEF} No output files were present for job "${taskids[$i]}
        continue
      else
        
        # Unpack tar file
        echo -e '  	==> output files :'
        
        if [ $pnfs -eq 0 ];then
          fileList=`(tar tzf $tarFile)`
        else
          fileList=`ls $pnfsdir${sandboxes[$i]}`
        fi
        
        for file in $fileList ; do
	
	  #making output file name
          test=`echo $file | (grep "\.")`
          if [ ! -z $test ] ; then
            first=`(echo  $file | awk '{split($0,a,"."); n=0 ; for (i in a) n++ ; nm1=n-1; for (i=1; i<nm1; i++) printf a[i]"." ; print a[nm1]"_" }')`
            middle=$taskName'_'$tagID'_'$i'.'
            last=`(echo  $file | awk '{split($0,a,"."); n=0 ; for (i in a) n++ ; print a[n]}')`
            outfile=$first$middle$last
          else
            outfile=$file"_"$taskName'_'$tagID'_'$i
          fi
          
	  #untaring/copying the files
          if [ $pnfs -eq 0 ];then
            tar xzf $tarFile $file 
            mv $file ../$outfile
          else
            dccp $pnfsdir${sandboxes[$i]}/$file ../$outfile &> /dev/null
          fi
        	     
          echo -e "		 ${YEL}$outDir/$outfile${DEF}"
        done
      fi
      
      
      
      # Copy logfiles
  
      errFileIn="${sandboxes[$i]}/stderr"
      outFileIn="${sandboxes[$i]}/stdout"
  
      errFileOut=$taskDir"/stderr_$i"
      outFileOut=$taskDir"/stdout_$i"
  
      cp $errFileIn $errFileOut
      cp $outFileIn $outFileOut
    
  
      # Remove SubTask SandBox
      if [ $clean -eq 1 ];then
        rm -rf ${sandboxes[$i]}
      fi
      
      
    done
    cd ..
    rm -rf $tmpdir 
    
    
    if [ $clean -eq 1 ];then
      # Remove Task SandBox
      rm -rf $taskSdb
      if [ $pnfs -eq 0 ];then
        rm -fr $pnfsdir$taskSdb
      fi
      
      # Remove Task form ongoing DB 
      remove_task_from_db
    fi
  
    
  done
  
}

resubmit(){

  get_specific_task
  
  tarFile="OutputSandbox.tgz"
  for i in `seq 0 $( expr $nJobs - 1 )` ; do
    cd ${sandboxes[$i]}
    
    #checking if $tarFile is present
    if [[ ! -f $tarFile && $pnfs -eq 0 ]] || [[ $pnfs -gt 0  && `ls $pnfsdir${sandboxes[$i]}|wc -l` -eq 0 ]];then
      echo -e "${CYAN}[btask] WARNING :${DEF} No output files were present for job "${taskids[$i]}
      echo -e "	    ==> resubmitting the job ${YEL}${taskids[$i]}${DEF}"
      qsub -N ${taskids[$i]} -q localgrid@cream01 -o `pwd`/stdout_retry -e `pwd`/stderr_retry qsub.sh > /dev/null
    fi
  done

}

resubmit_all(){

 get_tasks

  for job in $joblist ; do
    job=`echo $job | sed "s:;: :g"` 
    get_para_from_db
    
    echo -e "\n------------------------- Task : ${BLUE}$taskFullName${DEF}  ----------------------------"
    taskname=$taskFullName
    
    resubmit
  done
}



# ----------------------------  Parsing  Arguments  ----------------------------

submit=0
status=0
getout=0
jkill=0
resubmit=0
addroot=0
hadd_tweak=0
tag="NULL"
taskname="NULL"
pnfs=0

for arg in $* ; do

  case $arg in
    -submit)      submit=1   ; option=$2   ; shift ; shift ;;
    -status)      status=1                         ; shift ;;
    -get)         getout=1                         ; shift ;;
    -kill)        jkill=1                          ; shift ;;
    -resubmit)    resubmit=1 			   ; shift ;;
    -hadd)        addroot=1  			   ; shift ;;
    -hadd_tweak)  addroot=1 ; hadd_tweak=1	   ; shift ;;
    -task)                     taskname=$2 ; shift ; shift ;;
    -tag)                      tag=$2      ; shift ; shift ;;
    -pnfs)        pnfs=1 			   ; shift ;;
    -help)        Usage ;;
    *) ;;
  esac

done

# Check arguments (Only one action per command)

test=0
test=`expr $test + $submit`
test=`expr $test + $status`
test=`expr $test + $getout`
test=`expr $test + $jkill`
test=`expr $test + $resubmit`
test=`expr $test + $addroot`

if [ $test -eq 0 ] ; then
  echo -e "${RED}[btask] ERROR :${DEF} No valid arguments !"
  Usage
fi
if [ $test -gt 1 ] ; then
  echo -e "${RED}[btask] ERROR :${DEF} Can not do submit, status, get, resubmit, hadd at the same time !"
  Usage
fi

# ------------------------  SUBMIT  JOB(S) --------------------------------------

if [ $submit -eq 1 ] ; then

  cfg=$option 
  parse_config
  echo -e "${GREEN}[btask] INFO :${DEF} The following config will be used to start a task:"
  check_config
  print_config
  mkdir_task
  make_autofilelist
  submit_jobs
  add_task_to_db

fi # end [ $submit -eq 1 ] 

# ------------------------  KILL JOB(S) -----------------------------------------

if [ $jkill  -eq 1 ] ; then

  kill_jobs

fi # end [ $jkill  -eq 1 ]

# ------------------------  RESUBMIT  JOB(S) ------------------------------------

if [ $resubmit -eq 1 ] ; then

  if [ "$taskname" == "NULL" ];then
    resubmit_all
  else
    resubmit
  fi

fi # end [ $resubmit -eq 1 ] 


# ------------------------  JOB(S) STATUS --------------------------------------

if [ $status -eq 1 ] ; then

  print_status

fi # end [ $status -eq 1 ]

# ------------------------  JOB(S) OUTPUT  RETRIEVAL  --------------------------

if [ $getout -eq 1 ] ; then

  get_out

fi # end [ $getout -eq 1 ] 

# ------------------------  JOB(S) OUTPUT  MERGE  ------------------------------

if [ $addroot -eq 1 ] ; then

  if [ "$taskname" == "NULL" ];then
    hadd_all
  else
    make_hadd_job
  fi
  
fi # end [ $addroot -eq 1 ]


 
